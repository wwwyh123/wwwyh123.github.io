<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>guigu2 | HRecording</title><meta name="author" content="Wyh"><meta name="copyright" content="Wyh"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="login组件的静态页面需要掌握的element插件的使用https:&#x2F;&#x2F;element-plus.org&#x2F;zh-CN&#x2F;component&#x2F;input.html如果是组件的话需要引入，并且要动态绑定，例如：&lt;el-input type&#x3D;&quot;password&quot; :show-password&#x3D;true  :prefix-icon&#x3D;&quot;Unlock&quot; v-mod">
<meta property="og:type" content="article">
<meta property="og:title" content="guigu2">
<meta property="og:url" content="http://wwwyh123.github.io/2024/11/10/guigu2/index.html">
<meta property="og:site_name" content="HRecording">
<meta property="og:description" content="login组件的静态页面需要掌握的element插件的使用https:&#x2F;&#x2F;element-plus.org&#x2F;zh-CN&#x2F;component&#x2F;input.html如果是组件的话需要引入，并且要动态绑定，例如：&lt;el-input type&#x3D;&quot;password&quot; :show-password&#x3D;true  :prefix-icon&#x3D;&quot;Unlock&quot; v-mod">
<meta property="og:locale">
<meta property="og:image" content="http://wwwyh123.github.io/images/xu2.jpg">
<meta property="article:published_time" content="2024-11-10T09:41:01.000Z">
<meta property="article:modified_time" content="2024-11-28T14:35:05.786Z">
<meta property="article:author" content="Wyh">
<meta property="article:tag" content="硅谷甄选">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://wwwyh123.github.io/images/xu2.jpg"><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="http://wwwyh123.github.io/2024/11/10/guigu2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'guigu2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/xu2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">HRecording</span></a><a class="nav-page-title" href="/"><span class="site-name">guigu2</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">guigu2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-11-10T09:41:01.000Z" title="Created 2024-11-10 17:41:01">2024-11-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-11-28T14:35:05.786Z" title="Updated 2024-11-28 22:35:05">2024-11-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">9.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>33mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="login组件的静态页面"><a href="#login组件的静态页面" class="headerlink" title="login组件的静态页面"></a>login组件的静态页面</h2><h3 id="需要掌握的element插件的使用"><a href="#需要掌握的element插件的使用" class="headerlink" title="需要掌握的element插件的使用"></a>需要掌握的element插件的使用</h3><p><a target="_blank" rel="noopener" href="https://element-plus.org/zh-CN/component/input.html">https://element-plus.org/zh-CN/component/input.html</a><br>如果是组件的话需要引入，并且要动态绑定，例如：<br><code>&lt;el-input type=&quot;password&quot; :show-password=true  :prefix-icon=&quot;Unlock&quot; v-model=&quot;loginForm.password&quot;&gt;&lt;/el-input&gt;</code></p>
<h2 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h2><h3 id="try-块"><a href="#try-块" class="headerlink" title="try 块"></a>try 块</h3><p>try 块包含了可能会产生错误的代码。当 try 块中的代码执行时，如果抛出了错误，并且这个错误没有被 try 块内部的任何代码捕获，那么程序的控制流就会跳转到与 try 块相关联的 catch 块（如果有的话）。</p>
<h3 id="catch-块"><a href="#catch-块" class="headerlink" title="catch 块"></a>catch 块</h3><p>catch 块紧跟在 try 块之后，并且只会在 try 块中的代码抛出一个错误时执行。catch 块通常包含用于处理错误的代码，比如记录错误信息、清理资源、向用户显示错误消息等。<br>在 catch 块中，你可以访问一个特殊的变量（通常命名为 error 或 e），它包含了错误的详细信息。这个变量是 try 块中抛出的错误对象的一个实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">  await useStore.userLogin(loginForm)</span><br><span class="line">  //编程式导航 </span><br><span class="line">  $router.push(&#x27;/&#x27;)</span><br><span class="line">  ElNotification(&#123;</span><br><span class="line">    type: &#x27;success&#x27;,</span><br><span class="line">    message:&#x27;登录成功&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">  IsSuccess.value=false</span><br><span class="line">&#125;catch(error)&#123;</span><br><span class="line">  //登陆失败</span><br><span class="line">  IsSuccess.value=false</span><br><span class="line">  ElNotification(&#123;</span><br><span class="line">    type: &#x27;error&#x27;,</span><br><span class="line">    message: &#x27;登录失败&#x27;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>useStore.userLogin(loginForm)</code>会返回正确或错误信息，如果返回的是正确的，那么就把try中的代码执行完；反之，就执行catch块中的；ElNotification是el组件库；<br>.then(result &#x3D;&gt; { … }) 方法在 Promise 成功解决时被调用，result 是 userLogin 函数解决时返回的值。<br>.catch(error &#x3D;&gt; { … }) 方法在 Promise 被拒绝时被调用，error 是拒绝的原因。<br>转化成.then的形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const login = () =&gt; &#123;</span><br><span class="line">  // 开始加载，假设 IsSuccess 是一个响应式引用</span><br><span class="line">  IsSuccess.value = true;</span><br><span class="line">  // 调用仓库的登录请求，并处理 Promise</span><br><span class="line">  useStore.userLogin(loginForm)</span><br><span class="line">    .then(result =&gt; &#123;</span><br><span class="line">      // 请求成功后的操作</span><br><span class="line">      // 编程式导航到首页</span><br><span class="line">      $router.push(&#x27;/&#x27;);</span><br><span class="line">      // 显示登录成功的通知</span><br><span class="line">      ElNotification(&#123;</span><br><span class="line">        type: &#x27;success&#x27;,</span><br><span class="line">        message: &#x27;登录成功&#x27;</span><br><span class="line">      &#125;);</span><br><span class="line">      IsSuccess.value = false;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(error =&gt; &#123;</span><br><span class="line">      // 请求失败后的操作</span><br><span class="line">      IsSuccess.value = false;</span><br><span class="line">      // 显示登录失败的通知</span><br><span class="line">      ElNotification(&#123;</span><br><span class="line">        type: &#x27;error&#x27;,</span><br><span class="line">        message: &#x27;登录失败&#x27; </span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="菜单栏的封装"><a href="#菜单栏的封装" class="headerlink" title="菜单栏的封装"></a>菜单栏的封装</h2><p>2024-11-11;今天主要完成了这个部分。<br>大体思路是：菜单栏是一些路由的“集合”，我们期望可以通过每一个选项（路由）获得相应的组件。我们先对菜单组件进行封装，因为不同的身份登录，会展示不同的选项，考虑到复用性。在菜单组件中，我们又期望可以路由信息，从路由信息的角度命名每个选项，这样当我们选择时，右侧展示区域就可以轻易的展示出对应的信息。那么如何获得路由信息呢？1.路由信息已经对外暴露，我们只需要引入（pass）2.将路由信息导入我们的user仓库中，这样全局都可以查询路由信息，这时遇到了问题：关于export 和export default以及路由信息的类型定义问题(引入RouteRecordRaw)。然后，我们可以在父组件中引入仓库，再通过prop的方式传递给子组件。可是<strong>为什么不能直接在菜单组件中引入仓库呢？</strong>菜单组件拿到数据以后，可以将数据分为三类：1.没有二级路由的2.有一个二级路由的3.有两个及以上二级路由的。我们根据这三类，划分为两类，前两种直接将路由信息展示即可，后面一种需要折叠菜单，并且用到了<strong>递归思想</strong>，将二级路由再传递给当前组件，组件的递归需要再命名（在本组件中）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">  name: &#x27;Menu&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>然后呈现的应该是路由中meta属性中自定义的名字。这里就解释了上文<strong>为什么不能直接在菜单组件中引入仓库</strong>的问题，如果我们直接在子组件中引入的话，就无法实现递归，没有办法将当前的数据传递给自己。最后就是根据需求在meta中再定义一个hidden属性来就决定某个选项是否展示。<br>以下是一些总结：首先，菜单栏这部分主要用到el组件库的<code>&lt;el-scrollbar class=&quot;scrollbar&quot;&gt;</code>滑动，<code>&lt;el-menu background-color=&quot;#001529&quot; text-color=&quot;white&quot;&gt;</code>菜单，嵌套的元素是<code>&lt;el-menu-ite&gt;</code>,可以折叠的菜单<code>&lt;el-sub-menu&gt;</code>,组件库中用到的是这几项。一定要注意：<code>&lt;el-menu-ite&gt;</code>,<code>&lt;el-sub-menu&gt;</code>都在<code>&lt;el-menu&gt;</code>里面，否则会报错。<br>更为具体的用法为：<br>父组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-scrollbar class=&quot;scrollbar&quot;&gt;</span><br><span class="line">&lt;!-- 菜单组件 --&gt;</span><br><span class="line">  &lt;el-menu background-color=&quot;#001529&quot; text-color=&quot;white&quot;&gt;</span><br><span class="line">    &lt;Menu :menuList=&quot;userStore.menuRoutes&quot;&gt;&lt;/Menu&gt;</span><br><span class="line">  &lt;/el-menu&gt;</span><br><span class="line">&lt;/el-scrollbar&gt;  </span><br></pre></td></tr></table></figure>
<p>子组件：(这里只举了一个子组件的用法)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 没有子路由 --&gt;（外面有一个对父组件传递过来的数据的遍历）</span><br><span class="line">&lt;template v-if=&quot;!item.children&quot;&gt;</span><br><span class="line">  &lt;el-menu-item :index=&quot;item.path&quot; v-if=&quot;item.meta.hidden&quot;&gt;</span><br><span class="line">  &lt;template #title&gt;//插槽，可以自定义标题的内容</span><br><span class="line">    &lt;span&gt;biao&amp;nbsp;&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123;item.meta.title&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<h2 id="在Vue-Router的路由视图中实现带有过渡效果的组件渲染"><a href="#在Vue-Router的路由视图中实现带有过渡效果的组件渲染" class="headerlink" title="在Vue Router的路由视图中实现带有过渡效果的组件渲染"></a>在Vue Router的路由视图中实现带有过渡效果的组件渲染</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view v-slot=&quot;&#123; Component &#125;&quot;&gt;</span><br><span class="line">  &lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt;</span><br><span class="line">    &lt;component :is=&quot;Component&quot; v-if=&quot;flag&quot;&gt;&lt;/component&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;component :is=&quot;Component&quot; v-if=&quot;flag&quot;&gt;&lt;/component&gt;</code>:<code>&lt;component&gt;</code>是Vue的一个动态组件，它的:is属性用于绑定一个组件，这个组件可以是已注册的组件，或者是一个组件的选项对象。在这里，:is&#x3D;”Component”意味着<code>&lt;component&gt;</code>将动态渲染由<code>&lt;router-view&gt;</code>插槽提供的Component.<br>v-slot&#x3D;”{ Component }”:<br>这里使用了Vue的插槽（slot）和作用域插槽（scoped slot）的概念。<code>&lt;router-view&gt;</code>的v-slot允许你访问到路由组件本身，而不是直接渲染它。这里的{ Component }是一个对象解构，它从<code>&lt;router-view&gt;</code>的作用域插槽中获取了一个名为Component的属性，这个属性代表了当前应该被渲染的路由组件。</p>
<h2 id="menu的collapse属性，面包屑，全屏模式"><a href="#menu的collapse属性，面包屑，全屏模式" class="headerlink" title="menu的collapse属性，面包屑，全屏模式"></a>menu的collapse属性，面包屑，全屏模式</h2><p><a target="_blank" rel="noopener" href="https://element-plus.org/zh-CN/component/menu.html#menu-%E8%8F%9C%E5%8D%95">https://element-plus.org/zh-CN/component/menu.html#menu-%E8%8F%9C%E5%8D%95</a><br>在 Vue Router 中，$route.matched 是一个数组，它包含了当前路由匹配到的所有嵌套路径片段的路由记录。这些路由记录是 routes 配置数组中的对象副本（包括在 children 数组中的路由记录）。<br>具体来说，当你访问一个 URL 时，Vue Router 会根据配置的路由规则进行匹配，找到与当前 URL 最匹配的路由记录，并将其存储在 $route 对象中。同时，$route.matched 会包含从根路由开始到当前路由的所有匹配到的路由记录，这些记录按照匹配顺序排列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const IsFullScreen=()=&gt;&#123;</span><br><span class="line">  let full = document.fullscreenElement</span><br><span class="line">  //如果不是全屏</span><br><span class="line">  if(full)&#123;</span><br><span class="line">    document.exitFullscreen()</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    document.documentElement.requestFullscreen()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>菜单折叠遇到的问题：图标的抖动，右边组件的抖动；解决办法：摒弃flex布局。<br>2024-11-13</p>
<h2 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h2><p>2024-11-13<br>登录成功后，服务器返回用户的唯一标识(Token)。然后在请求拦截器中通过请求头将Token发送到服务器端。页面挂载完毕后，向服务器发送请求获取用户信息，想要获取用户信息，就需要引入&#x2F;api&#x2F;user中的reqUserInfo的获取用户信息接口方法，由于用户信息会被多个组件用到，所以我们将获取到的信息存到仓库中，在仓库中如果请求成功了我们再存入数据，否则返回错误信息。这样其他任何组件都可以使用了。<br>遇到的困难就是用reqUserInfo接收所需要的用户信息时，数据类型不正确，导致无法正确引用。解决方案：把返回类型设置为any</p>
<h2 id="路由鉴权"><a href="#路由鉴权" class="headerlink" title="路由鉴权"></a>路由鉴权</h2><p>2024-11-14<br>在permission.ts文件中操作<br>当用户登陆成功后，切换路由时，要进行判断是否可以跳转路由。因此我们引入路由守卫（前置，后置）进行条件判断。（每次路由跳转前都会自动进行条件判断）<br>今天遇到的问题：用户信息正确但是登录失败，在用户没有登录时，TOKEN就已经存在<br>为什么，从主页退出登陆后再登录就可以，直接从login页面登录就不行<br>为什么程序一运行进入的是主页而不是登录页面？在哪规定的？答：在路由的定义里，我们把&#x2F;重定向到login 就会变成程序一运行就到登录页面，而&#x2F;重定向到Home就会直接到主页。<br>取消进度条右侧加载的小圈<code>Nprogress.configure(&#123; showSpinner: false &#125;);</code></p>
<p>由于token 会有过期的可能，（实例：淘宝登录，会隔一段时间让你重新登录账号），当每次切换路由时，我们利用路由守卫发送请求请求到服务端，获取用户信息。也就是只是改变了向服务器发请求获取用户信息的时机。以前是在页面挂载后，这种情况就忽视了token 过期的可能。<br>但是还有问题，如果手动修改了本地存储的值，那么切换路由时并不会返回到登陆页面，只有刷新时才会怎么解决？？？？？？？<br><code>[env.VITE_APP_BASE_API]</code>: 这种写法被称为计算属性名<br>VITE_APP_BASE_API&#x3D;myApiEndpoint在你的配置对象中，<code>[env.VITE_APP_BASE_API]</code>: 实际上会被解析为 “myApiEndpoint”这种写法的好处是，你可以通过修改环境变量来改变配置，而不需要直接修改代码。</p>
<h2 id="品牌管理模块–静态页面搭建和数据展示"><a href="#品牌管理模块–静态页面搭建和数据展示" class="headerlink" title="品牌管理模块–静态页面搭建和数据展示"></a>品牌管理模块–静态页面搭建和数据展示</h2><p>2024-11-15<br>首先今天遇到了一个关于路由方面问题，以前没有搞明白。就是如何在某个页面下的某一部分展示另一个二级路由组件。其实很简单：只需要在父组件中要被展示的地方放入<code>&lt;router-view&gt;</code>，这里就是展示你想要的东西（下面我们将这个组件称为展示组件）。接下来就是路由的配置！！！我们想让一个二级路由的组件展示在某个页面的某部分，需要将其以及路由的路径改为展示组件的路径，这样访问二级路由时，会首先访问展示组件的页面，然后检测到展示组件有<code>&lt;router-view&gt;</code>展示路由的地方，我们配置二级路由的路径时，写的就是一级路由下的。也就是说，虽然一级路由呈现的是layout组件，但它的路径仍然是&#x2F;src&#x2F;一级，二级路由的路径就是&#x2F;src&#x2F;一级&#x2F;二级。RouterView 组件可以使 Vue Router 知道你想要在哪里渲染当前 URL 路径对应的路由组件。一个路由（父路由）可以包含一个或多个嵌套的子路由。每个子路由都对应一个视图组件，这些子视图组件会被渲染到父视图组件的<code>&lt;router-view&gt;</code>。</p>
<h3 id="静态页面搭建主要用到以下几个el组件"><a href="#静态页面搭建主要用到以下几个el组件" class="headerlink" title="静态页面搭建主要用到以下几个el组件"></a>静态页面搭建主要用到以下几个el组件</h3><h4 id="pagination分页器"><a href="#pagination分页器" class="headerlink" title="pagination分页器"></a>pagination分页器</h4><p><a target="_blank" rel="noopener" href="https://element-plus.org/zh-CN/component/pagination.html#pagination-%E5%88%86%E9%A1%B5">https://element-plus.org/zh-CN/component/pagination.html#pagination-%E5%88%86%E9%A1%B5</a><br>v-model:current-page:设置分页器当前页码<br>v-model:page-size:设置每一个展示数据条数<br>page-sizes:用于设置下拉菜单数据<br>background:设置分页器按钮的背景颜色<br>layout:可以设置分页器六个子组件布局调整</p>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p><a target="_blank" rel="noopener" href="https://element-plus.org/zh-CN/component/table.html#table-%E8%A1%A8%E6%A0%BC">https://element-plus.org/zh-CN/component/table.html#table-%E8%A1%A8%E6%A0%BC</a><br>表格组件：用于展示已有得平台数据<br>table:—border:可以设置表格纵向是否有边框<br>table-column:—label:某一个列表 —width:设置这列宽度 —align:设置这一列对齐方式</p>
<h4 id="card卡片"><a href="#card卡片" class="headerlink" title="card卡片"></a>card卡片</h4><p><a target="_blank" rel="noopener" href="https://element-plus.org/zh-CN/component/card.html#card-%E5%8D%A1%E7%89%87">https://element-plus.org/zh-CN/component/card.html#card-%E5%8D%A1%E7%89%87</a></p>
<h3 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h3><p>大致思路：我们拿到接口后，需要在&#x2F;src&#x2F;api中封装相关请求配置。首先在index.ts文件中枚举品牌管理的接口地址，然后封装获取已有品牌的接口方法；添加与修改已有品牌接口方法；删除某一个已有品牌的数据的方法.在type.ts文件中定义相关数据类型。接着在相关组件中就可以引入该文件后，使用这些方法发送请求，获得商品信息后渲染到组件中。<br>遇到的问题：<br>1.代理跨域<br>用脚手架写的项目：在config.js中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      &#x27;/api&#x27;: &#123;</span><br><span class="line">        target: &#x27;http://your-api-server.com&#x27;, // 目标服务器地址</span><br><span class="line">        changeOrigin: true, // 是否改变源地址</span><br><span class="line">        pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125; // 路径重写规则</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个配置中，所有以&#x2F;api开头的请求都会被代理到<a target="_blank" rel="noopener" href="http://your-api-server.com上,并且会去掉/api%E5%89%8D%E7%BC%80%E3%80%82">http://your-api-server.com上，并且会去掉/api前缀。</a><br>配置好代理后，前端代码就可以像访问同域资源一样访问跨域资源了。<br>使用Axios、Fetch API等发起请求时，只需将URL设置为代理规则中定义的路径（如&#x2F;api&#x2F;xxx）。<br>用vite：在config.ts中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">  &quot;/api/admin/acl&quot;: &#123; // 更新代理规则以匹配新的路径</span><br><span class="line">    target: &quot;http://sph-api.atguigu.cn&quot;, // 目标后端服务</span><br><span class="line">    changeOrigin: true,</span><br><span class="line">    rewrite: (path) =&gt; path.replace(/^\/api/, &#x27;&#x27;),</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;/api&quot;: &#123;</span><br><span class="line">    //获取数据的服务器地址设置</span><br><span class="line">    target: &quot;http://39.98.123.211:8510&quot;,</span><br><span class="line">    //需要代理跨域</span><br><span class="line">    changeOrigin: true,</span><br><span class="line">    //路径重写</span><br><span class="line">    rewrite: (path) =&gt; path.replace(/^\/api/, &#x27;&#x27;),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析：<br>第一个代理规则：<br>路径匹配：&#x2F;api&#x2F;admin&#x2F;acl<br>目标服务器：<a target="_blank" rel="noopener" href="http://sph-api.atguigu.cn/">http://sph-api.atguigu.cn</a><br>changeOrigin: true：表示会改变请求的源地址（即Host头），这对于虚拟主机场景是必需的。<br>rewrite函数：将请求路径中的&#x2F;api前缀替换为空字符串（实际上，由于路径是&#x2F;api&#x2F;admin&#x2F;acl，它会匹配并替换开头的&#x2F;api&#x2F;部分，但在这个特定例子中，由于路径已经包含更具体的&#x2F;admin&#x2F;acl后缀，所以替换后的路径将是&#x2F;admin&#x2F;acl）。不过，这里的rewrite函数可以更精确地写为path.replace(&#x2F;^/api/admin/acl&#x2F;, ‘&#x2F;admin&#x2F;acl’)（但这样做是多余的，因为当路径完全匹配时，替换为空字符串也能达到相同效果，只要后端服务期望的路径是&#x2F;admin&#x2F;acl）。<br>第二个代理规则：<br>路径匹配：&#x2F;api（这是一个更通用的匹配模式，会匹配所有以&#x2F;api开头的路径）<br>目标服务器：<a target="_blank" rel="noopener" href="http://39.98.123.211:8510/">http://39.98.123.211:8510</a><br>changeOrigin: true：同样表示会改变请求的源地址。<br>rewrite函数：将请求路径中的&#x2F;api前缀替换为空字符串。这意味着，如果请求的路径是&#x2F;api&#x2F;some&#x2F;endpoint，那么代理后的路径将是&#x2F;some&#x2F;endpoint。<br><strong>每个请求都会根据它的路径被代理到相应的后端服务，但每个请求只会被代理一次。</strong><br>2.向尚硅谷服务器发送请求Host: localhost:5173为什么是本地服务器<br>3.分页器不显示，检查后端返回的数据total<br>4.<code>&lt;el-table&gt;</code>的使用<br>5.当用ref监测请求返回的数组时，分页器可以正常运作；但用reactive就无法运作<br>答：因为新的数组不是响应式的，所以被赋值的数组也不会保留响应式的属性，你可以这样做reactiveArray &#x3D; reactive([4, 5, 6]); &#x2F;&#x2F; 新的数组也是响应式的<br>好像不太对呢？？？？？？<br>组件pagination父组件回传了数据(当前的页码)</p>
<h2 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h2><p>需要用到el-form的API以及一些方法;需要注意一个问题，就是清除表单数据的结果的时机，初次点击添加品牌时，表单元素还未生成，此时loginForm.value.clearValidate(‘logoUrl’)的返回值是undefined；因此我们有两个方法避免这个问题：<br>1.ts的写法：loginForm.value?.clearValidate(‘logoUrl’)<br>2.更新后的数据<br>nextTick(()&#x3D;&gt;{<br>  loginForm.value.clearValidate(‘tmName’)<br>})</p>
<h2 id="品牌管理模块删除业务"><a href="#品牌管理模块删除业务" class="headerlink" title="品牌管理模块删除业务"></a>品牌管理模块删除业务</h2><p>这里遇到的困难还是和ts数据类型的定义有关</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table-column label=&quot;品牌操作&quot;&gt;</span><br><span class="line">  &lt;template #default=&quot;&#123;row&#125;&quot;&gt;</span><br><span class="line">    &lt;el-button icon=&quot;Edit&quot; @click=&quot;editLogo(row)&quot;&gt;&lt;/el-button&gt;</span><br><span class="line">    &lt;!-- 删除按钮的气泡框 --&gt;</span><br><span class="line">      &lt;el-popover :visible=&quot;visible[row.id]&quot; placement=&quot;top&quot; :width=&quot;160&quot;&gt;</span><br><span class="line">        &lt;p&gt;确定要删除该品牌的信息吗？&lt;/p&gt;</span><br><span class="line">        &lt;div style=&quot;text-align: right; margin: 0&quot;&gt;</span><br><span class="line">          &lt;el-button size=&quot;small&quot; @click=&quot;missdeleteLogo(row.id)&quot;&gt;取消&lt;/el-button&gt;</span><br><span class="line">          &lt;el-button size=&quot;small&quot; type=&quot;primary&quot; @click=&quot;confirmdeleteLogo(row.id)&quot;&gt;确认&lt;/el-button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;template #reference&gt;</span><br><span class="line">          &lt;el-button icon=&quot;Delete&quot; @click=&quot;deleteLogo(row.id)&quot;&gt;&lt;/el-button&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">      &lt;/el-popover&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/el-table-column&gt;</span><br></pre></td></tr></table></figure>
<p>这里我们不能直接把气泡框的状态用点击按钮进行切换，因为这样会使整个页面的气泡框处于一个共享的状态，一旦有一个出现，其他也会出现。因此我们应该绑定事件，并传入id。<br><code>let visible = ref&lt;boolean[]&gt;([])</code>状态数组的定义<code>visible.value[id] = false</code>状态数组的访问</p>
<h2 id="属性管理模块数据展示"><a href="#属性管理模块数据展示" class="headerlink" title="属性管理模块数据展示"></a>属性管理模块数据展示</h2><p>基本流程：当选定一级数据后根据一级的id才会有二级的数据，二级的数据选定后根据二级的id才会有三级的数据，三级的数据选定后才会有下面页面的展示。<br>基本思路：因为很多组件都会用到关于属性的数据，所以我们把它存入仓库中。在属性管理模块，当页面挂载完成时，应该发送请求获取一级数据，并将其还有一级id存入仓库中;一级数据选择完毕后，带着一级的id发送请求获取二级数据，并将其还有二级id存入仓库中；以此类推。因为数据要存储在仓库中，在在仓库中定义一个发送请求的函数方便赋值，在组件中直接调用即可。<br>如何知道是否获取某一级的id?答：可以用change事件，绑定一个回调函数。当select框的选中值发生变化时，触发事件。（当用户从下拉菜单中选择一个选项时，<code>&lt;el-select&gt;</code> 的 v-model 绑定的值会自动更新为被选中 <code>&lt;el-option&gt;</code>的 value 值。）<br>下面的展示模块：<br>将发送请求得到的数组存入当前组件的响应式数组中，然后给el-table元素中注入 data 对象数组后，每一列进行相应的遍历可以用prop或插槽<br>#default: 这是v-slot指令的缩写形式，其中#是v-slot:的简写。default指的是默认插槽的名称<br>{row}: 这是传递给插槽的作用域（scope），它定义了一个名为row的变量，这个变量在插槽的内容中可用。作用域插槽允许子组件将数据传递给父组件的插槽内容。</p>
<h2 id="属性管理模块数据管理"><a href="#属性管理模块数据管理" class="headerlink" title="属性管理模块数据管理"></a>属性管理模块数据管理</h2><p>当进入添加属性模块时，上面的三个下拉菜单被禁用，父子之间通信，用props，definepropty</p>
<p>添加新的属性的业务：利用表单收集，需要收集的数据有：新增属性的名字,新增的属性值数组,三级分类的id(具体给哪个物品添加属性)<br>属性名字利用v-model收集即可；<br>新增的属性值数组的收集就是每点击一次新增属性按钮，就把input收集到的v-model，Push进数组即可。<br>三级分类的id因为是存在仓库中，所以很容易被访问到。<br><strong>清空上次遗留的数据</strong>在每次点击新增属性按钮后，清空组件定义的ref对象的数据；Object.assign() 是 JavaScript 中的一个方法，用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。该方法主要用于对象合并或属性的浅拷贝。<br>收集完发请求。</p>
<p>添加属性的input和div的切换:还有两个特殊情况，当input为空时，不能切换；当input的内容和前面的有重复时，不能切换。</p>
<p>添加属性值的编辑模式：自动聚焦：1.当点击添加属性值按钮时，表单收集的数组的最后一个input元素自动聚焦。2.点击某个input元素（由div切换至input时），自动聚焦。<br>这个功能主要用到的思路是：利用ref获取input的dom元素，存在一个数组中。并且input有一个focus属性，可以聚焦，当出现上述两种情况时，用focus聚焦即可。并且，因为渲染页面需要一定的时间，我们不能立刻获取到dom元素，所以要使用nextTick，等页面数据更新完毕之后再进行更改。</p>
<p>属性值的编辑模式：当点击编辑按钮时，视图切换，与上述不同的是，需要把当前物品的所有属性在表格中做一个呈现。之前，在el-table上我们绑定的数组attrParams.attrValueList，用作添加新的属性的呈现，现在可以在点击编辑按钮时把当前的属性值（row）赋值给该数组。<strong>注意</strong>：这里如果直接用Object.assign()，就会导致浅拷贝，也就是当你编辑新的属性值的时候，即使未点击保存，也会将已经写入的属性值添加到数组中，在查看模式中呈现出来。因此我们这里需要用到的是深拷贝。 <code>Object.assign(attrParams,JSON.parse(JSON.stringify(row)))</code><br>JSON.stringify(row)：这个方法将 row 对象转换成一个 JSON 字符串。这个过程是深拷贝的一部分，因为它创建了一个完全独立的字符串表示。<br>JSON.parse(…)：这个方法将上一步生成的 JSON 字符串解析回一个 JavaScript 对象。因为这是一个<strong>全新的对象</strong>，所以这是一个深拷贝的过程，它创建了 row 的一个完全独立的副本。<br>Object.assign(attrParams, …)：这个方法将上一步创建的 row 的深拷贝对象的所有可枚举属性复制到 attrParams 对象中。如果 attrParams 和深拷贝对象有相同的属性，则 attrParams 中的属性值将被深拷贝对象的属性值覆盖。</p>
<h2 id="SPU模块"><a href="#SPU模块" class="headerlink" title="SPU模块"></a>SPU模块</h2><p>当进入spu组件时，点击取消按钮后，要返回到spu模块的主页面，需要场景切换。但是spu组件是子组件，要给父index传数据，我们可以采用自定义事件。在父组件中，子组件的实例对象身上绑定一个自定义事件并让他等于父组件的一个回调函数，在子组件中用defineprops接收后，调用并传递参数。</p>
<h3 id="index的编辑模式："><a href="#index的编辑模式：" class="headerlink" title="index的编辑模式："></a>index的编辑模式：</h3><p>当点击编辑按钮时，场景切换，同时，还需要把当前品牌的数据渲染在页面中。但是我们拿到的数据是不完整的，还需要再发四个请求获得：全部品牌信息，商品图片，商品属性，商品的全部属性。<br>首先我们要考虑什么时候发送请求拿到数据然后渲染页面：<br>页面挂载时？答案是否定的，因为组件用的是v-show，也就意味着当父组件挂载完毕时，子组件也已经存在。这时候无法发送请求，因为可能还没有拿到三级数据的ID,所以pass。<br>点击编辑按钮时？当点击编辑按钮时，发送请求。我们要考虑的就是，数据应该在子组件中被拿到，然后呈现在页面上。因为如果在父组件中拿到的话，还要把数据传给子组件，就非常麻烦，因此我们需要做到<strong>在子组件中发送请求</strong>拿到数据。可是，点击编辑按钮时的row的数据还要再传给子组件吗？我们有另一个办法！用<strong>ref</strong>，获取到子组件的dom元素，这也就意味着，我们可以在父组件中随意的使用子组件身上的任何属性和方法。接着，在子组件内部定义一个方法，发送请求获取数据，**记得要对外暴露！defineExpose({sendreq})**至于row，我们可以用父组件调用该方法时传递参数给子组件。</p>
<h3 id="计算当前SPU还未拥有的销售属性"><a href="#计算当前SPU还未拥有的销售属性" class="headerlink" title="计算当前SPU还未拥有的销售属性"></a>计算当前SPU还未拥有的销售属性</h3><p>Array.prototype.every() 是 JavaScript 中数组的一个方法，用于测试数组的所有元素是否都通过了由提供的函数实现的测试。如果数组中所有元素都通过了测试，则返回 true，否则返回 false。<br>Array.prototype.filter() 是 JavaScript 数组的一个方法，它用于创建一个新数组，这个新数组包含通过所提供函数实现的测试的所有元素。简而言之，filter 方法会遍历数组中的每一个元素，并应用一个测试函数（回调函数），将返回 true 的元素添加到新数组中，最终返回这个新数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let unSelectSaleAttr = computed(()=&gt;&#123;</span><br><span class="line">  let unSelectArr = AllAttrs.value.filter(item=&gt;&#123;//所有的属性：颜色，尺寸</span><br><span class="line">    return Attrs.value.every(item1=&gt;&#123;//该商品的属性：颜色</span><br><span class="line">      return item.name != item1.saleAttrName</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  return unSelectArr</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>并且使用:value和v-model把没有被选择的属性的编号以及属性名收集。为了方便点击添加属性按钮时的操作，我们可以把收集好的数据封装成一个对象，然后直接push进数组即可。</p>
<h3 id="添加属性值模块："><a href="#添加属性值模块：" class="headerlink" title="添加属性值模块："></a>添加属性值模块：</h3><p>·添加属性值：需要给input绑定一个变量，收集数据，我们需要收集属性值的值，以及属性ID（给哪个属性添加的值），因为要把数据带给服务器，所以收集好之后，要封装成一个符合服务器字段名的对象，并推进数组<br>·切换按钮和input框：设置一个变量即可，还需要把上次input收集到的数据清空<br>·属性值不能为空trim()，不能重复find的判断<br>·数据收集完毕，发送请求。因为照片墙部分将属性名改了，所以还要再改回来。</p>
<h3 id="添加新的属性："><a href="#添加新的属性：" class="headerlink" title="添加新的属性："></a>添加新的属性：</h3><p>在子组件上定义一个方法，用来发送请求。在父组件中，用ref获取到子组件的组件实例对象后，调用该方法，发送请求。但是，我们需要点明是在哪个商品上添加的属性，所以需要父组件把c3id传给子组件。然后只需要发送两个请求，获取其他品牌和销售属性即可，剩下的数据都是需要被收集后发送post请求带上去的。还有就是一些清空业务。</p>
<h2 id="SKU模块"><a href="#SKU模块" class="headerlink" title="SKU模块"></a>SKU模块</h2><h3 id="获取SKU数据"><a href="#获取SKU数据" class="headerlink" title="获取SKU数据"></a>获取SKU数据</h3><p>与spu相同，我们想在点击增加sku按钮时，切换场景：在父组件中的子组件实例对象上绑定一个自定义事件，并带参数，当在子组件中点击取消按钮时，触发自定义事件，改变场景值即可。<br>·获取sku数据：我们想在父组件中点击添加按钮后，就发送请求，可是数据应该出现在子组件中。所以我们在父组件中用ref获取子组件实例对象，在子组件中定义一个发送请求的方法，并<strong>暴露</strong>(defineExpose({sendreq}))，在父组件中就可以调用该方法来发送请求，而数据在子组件中被获得。<br>数据收集到一个ref对象上;其中收集平台属性和销售属性时，先把每个属性值收集到属性对象的attrIdAndValueId上，因为我们当时定义ts类型时，将这两个数据的具体的值归为一个数组，所以需要我们全部收集完后再整理为一个数组发送给服务器。在这里我们要收集的是，属性id和属性值id，所以在option上的value绑定的是<code>$&#123;item.id&#125;:$&#123;it.id&#125;</code>然后利用v-model收集到select上绑定数据到属性对象的attrIdAndValueId上。<br>·设置默认图片，前面复选框自动勾选：首先我们要用ref获取table实例，然后用<strong>table</strong>的**toggleRowSelection(row,true)**方法（用于多选表格，切换某一行的选中状态， 如果使用了第二个参数，则可直接设置这一行选中与否）。给设置默认事件绑定点击按钮，由于只能有一个被选中，因此我们先遍历（保存的图片的数组）将其他的设为false，然后再将被选中的设为true。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const handler=(row:any)=&gt;&#123;</span><br><span class="line">  //收集默认图片的路径</span><br><span class="line">  skuParams.skuDefaultImg=row.imgUrl</span><br><span class="line">  //关于复选框</span><br><span class="line">  //点击的时候，全部图片的复选框均不勾选</span><br><span class="line">  Photos.value.forEach((item:any)=&gt;&#123;</span><br><span class="line">    table.value.toggleRowSelection(item,false)</span><br><span class="line">    console.log(item)</span><br><span class="line">  &#125;)</span><br><span class="line">  //被选中的图片的复选框勾选</span><br><span class="line">  table.value.toggleRowSelection(row,true)</span><br><span class="line">  console.log(row)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里注意，因为给table绑定的:data是图片数组，所以row是和item的元素是一样的。<br>·整理平台属性和销售属性的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let AttrArrs = AttrArr.value.reduce((prev:any,next:any)=&gt;&#123;</span><br><span class="line">  if(next.attrIdAndValueId)&#123;</span><br><span class="line">    let [attrId,valueId] = next.attrIdAndValueId.split(&#x27;:&#x27;)//那么使用split(&#x27;:&#x27;)方法将其值按冒号:分割成一个数组，并将这个数组解构为两个变量：attrId和valueId。</span><br><span class="line">    prev.push(&#123;</span><br><span class="line">      attrId,</span><br><span class="line">      valueId</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  return prev</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure>
<p><code>let [attrId,valueId] = next.attrIdAndValueId.split(&#39;:&#39;)</code><br>使用split(‘:’)方法将其值按冒号:分割成一个数组，并将这个数组解构为两个变量：attrId和valueId<br>回调函数返回prev，即更新后的累加器数组。这确保了reduce方法在下一次迭代时能够使用最新的数组。<br>关于reduce函数<br><code>array.reduce(callback(accumulator, currentValue, currentIndex, array), initialValue)</code><br>callback（必需）：一个执行数组中每个元素的函数，包含四个参数：<br>accumulator（累加器）：上一次调用回调时返回的累积值，或 initialValue（如果提供了 initialValue）。<br>currentValue（当前值）：数组中正在处理的当前元素。<br>currentIndex（当前索引）：数组中正在处理的当前元素的索引。如果提供了 initialValue，则从索引 0 开始；否则从索引 1 开始。<br>array（数组）：调用 reduce 的数组。<br>initialValue（可选）：作为第一次调用 callback 函数时的第一个参数的值。如果没有提供 initialValue，则将数组的第一个元素作为第一次调用 callback 的第一个参数，并且跳过数组的第一个元素，从第二个元素开始累加。</p>
<h2 id="用户管理模块"><a href="#用户管理模块" class="headerlink" title="用户管理模块"></a>用户管理模块</h2><h3 id="增加新账号和修改账号"><a href="#增加新账号和修改账号" class="headerlink" title="增加新账号和修改账号"></a>增加新账号和修改账号</h3><p>这里需要注意的就是：<br>1.每次点击增加新用户时，需要清空上次收集到的数据：用到了Object.assign(),还有清空表单项的校验提示信息。当页面挂载后，组件中并没有抽屉这个元素，因此我们应该用nextTick(),等页面把数据更新完毕后，再获取到表单项，用clearValidate清除。<br>2.当我们修改自己的账户信息时，原来的账号已经不存在，因此我们需要被重新登陆，用<code> window.location.reload()</code>该方法使浏览器自动刷新一次，利用当时我们写的路由守卫，被反弹到登录页面。</p>
<h3 id="用户管理的重置"><a href="#用户管理的重置" class="headerlink" title="用户管理的重置"></a>用户管理的重置</h3><p>用到的方法是仓库的reset</p>
<h3 id="分配权限"><a href="#分配权限" class="headerlink" title="分配权限"></a>分配权限</h3><p>当页面需要呈现出被选择用户的所有权限时，我们得到的数组需要被递归，因为结构一样，但是子数组中又有子数组，所以采用递归思想。并且，要想得到正确的被勾选的形式需要获取到level为4并且selection 为true 的id，并记录下来。</p>
<p>在JavaScript或TypeScript中，当你处理对象和变量时，赋值方式的选择会直接影响对象的引用和内容的更新。在你提供的代码片段中，你展示了两种清空MenuData对象属性的方法，并询问为什么使用第二种方法（直接赋值整个对象）会导致input无法呈现输入的值。</p>
<p>首先，我们需要明确一点：在你的代码中，MenuData很可能是一个响应式对象，特别是在你使用Vue或类似框架时。响应式对象通常具有特殊的getter和setter，以便在属性被访问或修改时触发更新。</p>
<p>使用 Object.assign()<br>javascript<br>Object.assign(MenuData, {<br>    code: ‘’,<br>    id: 0,<br>    level: 0,<br>    name: ‘’,<br>    pid: 0<br>});<br>当你使用Object.assign()时，你是在修改MenuData对象的现有实例。你并没有创建一个新的对象，而是将新属性复制到现有的MenuData对象中。这意味着MenuData的引用保持不变，但它的内容被更新了。由于MenuData是响应式的，Vue或类似框架能够检测到这些变化，并更新依赖于MenuData的任何视图或组件。</p>
<p>直接赋值整个对象<br>javascript<br>MenuData &#x3D; {<br>    code: ‘’,<br>    id: 0,<br>    level: 0,<br>    name: ‘’,<br>    pid: 0<br>};<br>当你直接赋值整个对象时，你实际上是在创建一个新的对象，并将其赋值给MenuData变量。这意味着MenuData现在指向一个新的对象引用，而不是原来的响应式对象。如果MenuData是在Vue组件的data函数中定义的，并且被用作响应式数据，那么这种赋值方式会破坏响应性。Vue将无法追踪新对象的属性变化，因为新对象没有Vue的响应式getter和setter。</p>
<p>为什么input无法呈现输入的值？<br>当你直接赋值整个对象时，如果MenuData是响应式的，并且你在模板中绑定了MenuData的某个属性到input的值，那么由于MenuData现在指向一个新的非响应式对象，Vue无法检测到属性的变化。因此，当你在input中输入值时，这个值不会被同步到新的MenuData对象中，也不会更新到Vue的响应式系统中。</p>
<h2 id="当切换路由时，路由切换成功但是页面上的组件不显示"><a href="#当切换路由时，路由切换成功但是页面上的组件不显示" class="headerlink" title="当切换路由时，路由切换成功但是页面上的组件不显示"></a>当切换路由时，路由切换成功但是页面上的组件不显示</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43185419/article/details/131187369">https://blog.csdn.net/weixin_43185419/article/details/131187369</a><br><keep-alive> 用于缓存组件实例，保留组件的状态，适用于需要保留用户输入或避免重复数据获取的场景。<br>在 <router-view> 上添加 :key 用于强制重新渲染组件，解决状态不一致的问题，适用于路由参数变化需要重置组件状态的场景。</router-view></keep-alive></p>
<h3 id="菜单管理"><a href="#菜单管理" class="headerlink" title="菜单管理"></a>菜单管理</h3><p>我们把路由分为三种：常量路由（任何用户都可以访问），异步路由（有人可以有人不可以），任意路由。<br>在登录发送请求时，我们可以获取到用户的所带路由的信息（用户被分配的权限，权限的名字就是路由的名字），拿用户可以访问的路由信息数组和我们定义的异步路由的数组进行对比，过滤出用户所拥有的路由权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function filterAsyncRoute(asnycRoute: any, routes: any) &#123;</span><br><span class="line">  return asnycRoute.filter((item: any) =&gt; &#123;</span><br><span class="line">    if (routes.includes(item.name)) &#123;</span><br><span class="line">      if (item.children &amp;&amp; item.children.length &gt; 0) &#123;</span><br><span class="line">        //硅谷333账号:product\trademark\attr\sku</span><br><span class="line">        item.children = filterAsyncRoute(item.children, routes)</span><br><span class="line">      &#125;</span><br><span class="line">      return true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用时需要深拷贝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const userAsyncRoute = filterAsyncRoute(</span><br><span class="line">  cloneDeep(asyncRoute),</span><br><span class="line">  result.data.routes,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>然后追加到用户信息仓库的路由信息中<code>this.menuRoutes = [...constantRoutes, ...userAsyncRoute, ...anyRoute];</code><br>但是此时并没有注册除常量路由以外的路由，所以我们还需要将获得的路由数组注册</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[...userAsyncRoute, anyRoute].forEach((route: any) =&gt; &#123;</span><br><span class="line">  router.addRoute(route)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="echarts使用步骤以及常用配置项"><a href="#echarts使用步骤以及常用配置项" class="headerlink" title="echarts使用步骤以及常用配置项"></a>echarts使用步骤以及常用配置项</h2><p>1.获取dom元素， <code>ref=&quot;charts&quot;</code>  <code>let charts = ref()</code><br>2.引入echarts <code>import * as echarts from &#39;echarts&#39;;</code><br>3.初始化 <code>let mycharts = echarts.init(charts.value)</code><br>4.设置配置项 <code>mycharts.setOption(option)</code></p>
<h3 id="常见的配置项"><a href="#常见的配置项" class="headerlink" title="常见的配置项"></a>常见的配置项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;</span><br><span class="line">  text: &#x27;主标题&#x27;,</span><br><span class="line">  subtext: &#x27;副标题&#x27;,</span><br><span class="line">  left: &#x27;center&#x27;, // 标题水平位置：&#x27;left&#x27; | &#x27;center&#x27; | &#x27;right&#x27;</span><br><span class="line">  textStyle: &#123; fontSize: 18, color: &#x27;#333&#x27; &#125;, // 主标题样式</span><br><span class="line">  subtextStyle: &#123; fontSize: 14, color: &#x27;#999&#x27; &#125;, // 副标题样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>管理图表系列的展示和交互</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">legend: &#123;</span><br><span class="line">  orient: &#x27;horizontal&#x27;, // 布局方向：&#x27;horizontal&#x27;(水平的) | &#x27;vertical&#x27;</span><br><span class="line">  left: &#x27;center&#x27;,</span><br><span class="line">  data: [&#x27;系列1&#x27;, &#x27;系列2&#x27;], // 对应 series.name</span><br><span class="line">  textStyle: &#123; color: &#x27;#000&#x27; &#125;, // 图例文字样式</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>tooltip（提示框）<br>显示鼠标悬浮时的数据详情。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tooltip: &#123;</span><br><span class="line">  trigger: &#x27;item&#x27;, // &#x27;item&#x27;: 针对数据项 | &#x27;axis&#x27;: 针对坐标轴</span><br><span class="line">  formatter: &#x27;&#123;a&#125; &lt;br/&gt;&#123;b&#125;: &#123;c&#125; (&#123;d&#125;%)&#x27;, // 自定义格式化内容</span><br><span class="line">  backgroundColor: &#x27;rgba(50,50,50,0.7)&#x27;, // 提示框背景色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>grid（网格）<br>设置坐标系在容器中的布局。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">grid: &#123;//饼状图中在legnd中设置</span><br><span class="line">  left: &#x27;10%&#x27;, // 距左边距</span><br><span class="line">  right: &#x27;10%&#x27;, // 距右边距</span><br><span class="line">  top: &#x27;15%&#x27;, // 距顶部</span><br><span class="line">  bottom: &#x27;10%&#x27;, // 距底部</span><br><span class="line">  containLabel: true, // 是否包含坐标轴刻度标签</span><br><span class="line">  containLabel: true//保证折线图的数据从 X 轴的起点开始绘制，避免视觉上的留白问题。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xAxis: &#123;</span><br><span class="line">  type: &#x27;category&#x27;, // 坐标轴类型：&#x27;value&#x27;（数值） | &#x27;category&#x27;（类目） | &#x27;time&#x27;（时间）</span><br><span class="line">  data: [&#x27;周一&#x27;, &#x27;周二&#x27;, &#x27;周三&#x27;], // 类目数据</span><br><span class="line">  axisLine: &#123; lineStyle: &#123; color: &#x27;#333&#x27; &#125; &#125;, // 坐标轴线样式</span><br><span class="line">  axisLabel: &#123; color: &#x27;#666&#x27; &#125; // 标签样式</span><br><span class="line">&#125;,</span><br><span class="line">yAxis: &#123;</span><br><span class="line">  type: &#x27;value&#x27;,</span><br><span class="line">  splitLine: &#123; lineStyle: &#123; type: &#x27;dashed&#x27;, color: &#x27;#ddd&#x27; &#125; &#125;, // 网格线样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


































































</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://wwwyh123.github.io">Wyh</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://wwwyh123.github.io/2024/11/10/guigu2/">http://wwwyh123.github.io/2024/11/10/guigu2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%A1%85%E8%B0%B7%E7%94%84%E9%80%89/">硅谷甄选</a></div><div class="post-share"><div class="social-share" data-image="/images/xu2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/11/10/%E5%85%B3%E4%BA%8EPinia/" title="关于Pinia"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">关于Pinia</div></div><div class="info-2"><div class="info-item-1">参考：https://pinia.vuejs.org/zh/getting-started.html Store 是什么？Store (如 Pinia) 是一个保存状态和业务逻辑的实体，它并不与你的组件树绑定。换句话说，它承载着全局状态。它有点像一个永远存在的组件，每个组件都可以读取和写入它。它有三个概念，state、getter 和 action，我们可以假设这些概念相当于组件中的 data、 computed 和 methods。 应该在什么时候使用 Store?一个 Store 应该包含可以在整个应用中访问的数据。这包括在许多地方使用的数据，例如显示在导航栏中的用户信息，以及需要通过页面保存的数据，例如一个非常复杂的多步骤表单。 另一方面，你应该避免在 Store 中引入那些原本可以在组件中保存的本地数据，例如，一个元素在页面中的可见性。 基本使用方法首先npm install pinia然后在入口文件中引入 12345import &#123; createPinia &#125; from &#x27;pinia&#x27;const pinia =...</div></div></div></a><a class="pagination-related" href="/2024/11/10/guigu/" title="项目中常用到的"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">项目中常用到的</div></div><div class="info-2"><div class="info-item-1">应用Element-plus插件插件被重复使用,国际化应用失败也是这里出错 1234app.use(ElementPlus)app.use(ElementPlus, &#123;  locale: zhCn,&#125;) 安装sass遇到的问题我们目前在组件内部已经可以使用scss样式,因为在配置styleLint工具的时候，项目当中已经安装过sass sass-loader,因此我们再组件内可以使用scss语法！！！需要加上lang&#x3D;”scss” 1&lt;style scoped lang=&quot;scss&quot;&gt;&lt;/style&gt; 接下来我们为项目添加一些全局的样式在src&#x2F;styles目录下创建一个index.scss文件，当然项目中需要用到清除默认样式，因此在index.scss引入reset.scss 1@import reset.scss 在入口文件引入 1import...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/xu2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Wyh</div><div class="author-info-description">正确的开始，微小的长进，然后持续。</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wwwyh123"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Welcome to my blog!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#login%E7%BB%84%E4%BB%B6%E7%9A%84%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">login组件的静态页面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84element%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">需要掌握的element插件的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try%E2%80%A6catch"><span class="toc-number">2.</span> <span class="toc-text">try…catch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#try-%E5%9D%97"><span class="toc-number">2.1.</span> <span class="toc-text">try 块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#catch-%E5%9D%97"><span class="toc-number">2.2.</span> <span class="toc-text">catch 块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8F%9C%E5%8D%95%E6%A0%8F%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">3.</span> <span class="toc-text">菜单栏的封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8Vue-Router%E7%9A%84%E8%B7%AF%E7%94%B1%E8%A7%86%E5%9B%BE%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%B8%A6%E6%9C%89%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C%E7%9A%84%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="toc-number">4.</span> <span class="toc-text">在Vue Router的路由视图中实现带有过渡效果的组件渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#menu%E7%9A%84collapse%E5%B1%9E%E6%80%A7%EF%BC%8C%E9%9D%A2%E5%8C%85%E5%B1%91%EF%BC%8C%E5%85%A8%E5%B1%8F%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">menu的collapse属性，面包屑，全屏模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-number">6.</span> <span class="toc-text">获取用户信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E9%89%B4%E6%9D%83"><span class="toc-number">7.</span> <span class="toc-text">路由鉴权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%81%E7%89%8C%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E2%80%93%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E6%95%B0%E6%8D%AE%E5%B1%95%E7%A4%BA"><span class="toc-number">8.</span> <span class="toc-text">品牌管理模块–静态页面搭建和数据展示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%90%AD%E5%BB%BA%E4%B8%BB%E8%A6%81%E7%94%A8%E5%88%B0%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AAel%E7%BB%84%E4%BB%B6"><span class="toc-number">8.1.</span> <span class="toc-text">静态页面搭建主要用到以下几个el组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pagination%E5%88%86%E9%A1%B5%E5%99%A8"><span class="toc-number">8.1.1.</span> <span class="toc-text">pagination分页器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E6%A0%BC"><span class="toc-number">8.1.2.</span> <span class="toc-text">表格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#card%E5%8D%A1%E7%89%87"><span class="toc-number">8.1.3.</span> <span class="toc-text">card卡片</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B1%95%E7%A4%BA"><span class="toc-number">8.2.</span> <span class="toc-text">数据展示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C"><span class="toc-number">9.</span> <span class="toc-text">表单校验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%81%E7%89%8C%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%88%A0%E9%99%A4%E4%B8%9A%E5%8A%A1"><span class="toc-number">10.</span> <span class="toc-text">品牌管理模块删除业务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E6%95%B0%E6%8D%AE%E5%B1%95%E7%A4%BA"><span class="toc-number">11.</span> <span class="toc-text">属性管理模块数据展示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86"><span class="toc-number">12.</span> <span class="toc-text">属性管理模块数据管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPU%E6%A8%A1%E5%9D%97"><span class="toc-number">13.</span> <span class="toc-text">SPU模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#index%E7%9A%84%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">13.1.</span> <span class="toc-text">index的编辑模式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%BD%93%E5%89%8DSPU%E8%BF%98%E6%9C%AA%E6%8B%A5%E6%9C%89%E7%9A%84%E9%94%80%E5%94%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">13.2.</span> <span class="toc-text">计算当前SPU还未拥有的销售属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%80%BC%E6%A8%A1%E5%9D%97%EF%BC%9A"><span class="toc-number">13.3.</span> <span class="toc-text">添加属性值模块：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%9A"><span class="toc-number">13.4.</span> <span class="toc-text">添加新的属性：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SKU%E6%A8%A1%E5%9D%97"><span class="toc-number">14.</span> <span class="toc-text">SKU模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96SKU%E6%95%B0%E6%8D%AE"><span class="toc-number">14.1.</span> <span class="toc-text">获取SKU数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97"><span class="toc-number">15.</span> <span class="toc-text">用户管理模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E6%96%B0%E8%B4%A6%E5%8F%B7%E5%92%8C%E4%BF%AE%E6%94%B9%E8%B4%A6%E5%8F%B7"><span class="toc-number">15.1.</span> <span class="toc-text">增加新账号和修改账号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E7%9A%84%E9%87%8D%E7%BD%AE"><span class="toc-number">15.2.</span> <span class="toc-text">用户管理的重置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E6%9D%83%E9%99%90"><span class="toc-number">15.3.</span> <span class="toc-text">分配权限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E5%88%87%E6%8D%A2%E8%B7%AF%E7%94%B1%E6%97%B6%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%88%87%E6%8D%A2%E6%88%90%E5%8A%9F%E4%BD%86%E6%98%AF%E9%A1%B5%E9%9D%A2%E4%B8%8A%E7%9A%84%E7%BB%84%E4%BB%B6%E4%B8%8D%E6%98%BE%E7%A4%BA"><span class="toc-number">16.</span> <span class="toc-text">当切换路由时，路由切换成功但是页面上的组件不显示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8F%9C%E5%8D%95%E7%AE%A1%E7%90%86"><span class="toc-number">16.1.</span> <span class="toc-text">菜单管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#echarts%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-number">17.</span> <span class="toc-text">echarts使用步骤以及常用配置项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-number">17.1.</span> <span class="toc-text">常见的配置项</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/24/%E5%8F%AF%E6%8B%96%E6%8B%BD%E7%BB%84%E4%BB%B6/" title="可拖拽组件">可拖拽组件</a><time datetime="2024-12-24T09:19:30.000Z" title="Created 2024-12-24 17:19:30">2024-12-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/16/node-js/" title="node.js">node.js</a><time datetime="2024-12-16T05:10:39.000Z" title="Created 2024-12-16 13:10:39">2024-12-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/13/git/" title="git">git</a><time datetime="2024-12-13T11:46:14.000Z" title="Created 2024-12-13 19:46:14">2024-12-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/13/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/" title="跨域问题">跨域问题</a><time datetime="2024-12-13T10:56:52.000Z" title="Created 2024-12-13 18:56:52">2024-12-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/09/java/" title="java">java</a><time datetime="2024-12-09T08:34:00.000Z" title="Created 2024-12-09 16:34:00">2024-12-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Wyh</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">2</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>