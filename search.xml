<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>可拖拽组件</title>
      <link href="/2024/12/24/%E5%8F%AF%E6%8B%96%E6%8B%BD%E7%BB%84%E4%BB%B6/"/>
      <url>/2024/12/24/%E5%8F%AF%E6%8B%96%E6%8B%BD%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>用到的原生DOM事件</p><ul><li><code>@mousedown=&quot;handlerMouseDown</code>，默认参数为event，鼠标等在dom元素上按下时触发事件</li><li><code>@dragover.prevent @drop=&quot;onDrop&quot;</code> 用于处理拖拽事件的指令；@dragover.prevent：这个指令监听 dragover 事件，.prevent 修饰符用于阻止事件的默认行为（默认行为可能会阻止放置操作）。</li></ul><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>将列表拆分成组件时，<code>onMouseDown</code>需要绑定在子组件上，但函数体在父组件中，因此用到了父子组件通信，由于是父给子传递信息，可以用props；但是，如果在子组件中直接写<code>@mousedown=&quot;handlerMouseDown(e, type)&quot;</code>的话，无法获取到事件e，因为 e 并不是在模板作用域中定义的变量。解决这个问题，可以有以下两种方法：</p><ol><li>直接使用箭头函数<code> @mousedown=&quot;(e) =&gt; handlerMouseDown(e, type)&quot;</code>(影响性能不推荐)</li><li>让 Vue 自动传递事件对象：<code> @mousedown=&quot;handlerMouseDown($event, type)&quot;</code></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>node.js</title>
      <link href="/2024/12/16/node-js/"/>
      <url>/2024/12/16/node-js/</url>
      
        <content type="html"><![CDATA[<ul><li>浏览器是js的前端运行环境</li><li>node.js是后端运行环境</li><li>node.js无法调用Dom,BOM,ajax等浏览器内置API</li><li>使用node.js执行js文件： node 文件名</li></ul><h1 id="内置API模块"><a href="#内置API模块" class="headerlink" title="内置API模块"></a>内置API模块</h1><h2 id="fs文件系统"><a href="#fs文件系统" class="headerlink" title="fs文件系统"></a>fs文件系统</h2><ol><li>导入fs<code>const fs=require(&#39;fs&#39;)</code></li><li>读取指定文件内容<code>fs.readFile(path[,options],callback)</code><br>callback(err,dataStr)回调函数可以拿到读取失败和成功的结果<br>读取成功：err为null<br>读取失败：dataStr为undefined</li><li>向指定文件写入内容<code>fs.writeFile(path,data[,options],callback)</code><br>data:写入内容<br>callback(err){}<br><strong>使用fs操作文件（相对路径）时，会以<font color="red">执行node命令所处的目录</font>动态拼接出被操纵文件的完整目录</strong><br>使用<code>__dirname</code>（表示当前文件所处目录）</li></ol><h2 id="Path模块"><a href="#Path模块" class="headerlink" title="Path模块"></a>Path模块</h2><ol><li>导入<code>const path = require(&#39;path&#39;)</code></li><li><code>path.join(&#39;/a&#39;,&#39;../b&#39;)</code>将多个路径片段拼接成一个完整的路径字符串——结果：’&#x2F;b’</li><li><code>path.basename(path[,ext])</code>从路径字符串中将文件名解析出来<br>ext:文件扩展名，如果传入扩展名，则返回结果时不带扩展名；如果不传，则返回  文件名.扩展名<br>返回值：string–表示路径中的最后一部分</li></ol><h2 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h2><h3 id="创建一个最基本的web服务器"><a href="#创建一个最基本的web服务器" class="headerlink" title="创建一个最基本的web服务器"></a>创建一个最基本的web服务器</h3><ol><li>导入<code>const http=require(&#39;http&#39;)</code></li><li>创建一个服务器实例<code>const server = http.createServer()</code></li><li>为服务器实例绑定request事件<code>server.on(&#39;request&#39;,function(req,res)=&gt;&#123;&#125;)</code></li></ol><ul><li>客户端请求地址req.url</li><li>客户端请求方式req.method</li><li>res.end()向客户端响应一些内容</li><li>防止中文乱码，设置响应头Content-Type的值为text&#x2F;html<code>res.setHeader(&#39;Content-Type&#39;, &#39;text/html;charset=utf-8&#39;);</code></li></ul><ol start="4"><li>启动服务器<code>server.listen(端口,function()=&gt;&#123;&#125;)</code></li></ol><h3 id="查看一个端口是否被占用"><a href="#查看一个端口是否被占用" class="headerlink" title="查看一个端口是否被占用"></a>查看一个端口是否被占用</h3><p><code>netstat -ano|findstr 8080</code><br><code>.taskkill -PID 13512 -F</code></p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="模块的分类"><a href="#模块的分类" class="headerlink" title="模块的分类"></a>模块的分类</h3><ul><li>内置模块（fs,path,http…）</li><li>自定义模块（用户创建的.js文件）</li><li>第三方模块(包，基于内置模块封装出来的)</li><li>外界用require()方法导入自定义模块时，得到的时modeule.exports所指对象（默认为空）<br>模块作用域：防止了全局变量的污染<br>用require()导入模块时，得到的永远是module.exports指向的对象<br>例如：<img src="/2024/12/16/node-js/image%20copy%202.png"><br>所以导入该模块时，得到的是下面的对象</li></ul><p>npm与包<br><code>npm init -y</code> 快速创建package.json文件<strong>项目文件夹不要包含中文和空格</strong><br><code>npm i</code>将package.json的dependencies的包全部安装<br><code>npm i -D </code>  <code>npm install 包名 --save-dev</code></p><ul><li>安装全局包<code>npm i -g </code>，卸载全局包<code>npm uninstall 包名 -g </code></li></ul><h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><p>创建一个基本的web服务器</p><ol><li><code>npm i express</code></li><li>导入express <code>const express = require(&#39;express&#39;)</code></li><li>创建web服务器<code>const app = express()</code></li><li>启动服务器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.listen(80,()=&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>Get请求<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x27;请求url&#x27;,function(req,res)&#123;&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>Post请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.post(&#x27;请求url&#x27;,function(req,res)&#123;&#125;)</span><br></pre></td></tr></table></figure><p>把内容相应给客户端<code>res.send()</code><br>获取URL中携带的查询参数<code>req.query()</code><br>获取URL中携带的动态参数<code>req.params()</code>，通过:匹配到动态参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x27;/user/:id&#x27;,(req,res)=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="托管静态资源express-static"><a href="#托管静态资源express-static" class="headerlink" title="托管静态资源express.static()"></a>托管静态资源express.static()</h2><p>例如：<code>app.use(express.static(&#39;public&#39;))</code><br>表示对外开放public这个文件夹<br>public不会出现在访问路径中<br>若使用<code>app.use(&#39;/public&#39;,express.static(&#39;public&#39;))</code><br>此时访问public目录中的文件时，需要加上&#x2F;public</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>express中的路由<br>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x27;/&#x27;,(req,res)=&#123;</span><br><span class="line">  res.send(&quot;asdhja&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用路由模块</p><ol><li>引入express<code>const express = require(&#39;express&#39;)</code></li><li>创建路由对象<code>const router = express.Router()</code></li><li>挂载具体路由，如上</li><li>暴露路由，module.exports&#x3D;router</li><li>在入口文件中引入<code>const useRouter=require(&#39;./router&#39;)</code></li><li>注册路由<code>app.use(useRouter)</code><br><code>app.use()</code>注册全局中间件</li></ol><h3 id="为路由添加前缀"><a href="#为路由添加前缀" class="headerlink" title="为路由添加前缀"></a>为路由添加前缀</h3><p><code>app.use(&#39;/api&#39;,useRouter)</code></p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><ul><li>注册在路由之前<font color="red">！！！错误级别的中间件除外！！！</font></li><li>作用：对请求进行预处理；多个中间件之间，共享同一份req和res，我们可以在上游的中间件中，统一为req或res对象添加自定义的属性或方法，供下游的中间件或路由进行使用。</li><li>注册为全局生效的中间件函数 app.use(中间件函数) 客户端发起任何请求，到达服务器后，都会触发的中间件</li><li>中间件函数的形参列表中<strong>必须包含next参数</strong>，而路由处理函数中只包含req和res</li></ul><h3 id="next-函数"><a href="#next-函数" class="headerlink" title="next()函数"></a>next()函数</h3><p>实现多个中间件连续调用，把流转关系转交给下一个中间件或者路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const mw = (req,res,next)=&gt;&#123;</span><br><span class="line">  console.log(&quot;这是一个最简单的中间件函数&quot;)</span><br><span class="line">  //把流转关系转交给下一个中间件或者路由</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部生效的中间件"><a href="#局部生效的中间件" class="headerlink" title="局部生效的中间件"></a>局部生效的中间件</h3><p><img src="/2024/12/16/node-js/image%20copy%203.png"><br><img src="/2024/12/16/node-js/image%20copy%204.png"></p><h3 id="中间件的分类"><a href="#中间件的分类" class="headerlink" title="中间件的分类"></a>中间件的分类</h3><h4 id="应用级别的中间件"><a href="#应用级别的中间件" class="headerlink" title="应用级别的中间件"></a>应用级别的中间件</h4><p>通过<code>app.use()</code> <code>app.get()</code> <code>app.post()</code> 绑定到app实例上的中间件</p><h4 id="路由级别的中间件"><a href="#路由级别的中间件" class="headerlink" title="路由级别的中间件"></a>路由级别的中间件</h4><p>绑定到express.Router()上的</p><h4 id="错误级别的中间件"><a href="#错误级别的中间件" class="headerlink" title="错误级别的中间件"></a>错误级别的中间件</h4><p><font color="red">错误级别的中间件必须注册在所有路由之后</font><br>捕获整个项目中发生的异常错误，防止项目异常崩溃(如果不加，程序直接崩溃，无法进行下去)<br>格式：<code>function(err,req,res,next)&#123;&#125;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  throw new Error(&quot;程序出错了！&quot;)</span><br><span class="line">  res.end(&quot;这里是&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">app.use((err, req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&quot;发生了粗哦&quot; + err.message)</span><br><span class="line">  res.send(&#x27;Error&#x27; + err.message)//Error程序出错了！</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Express-内置的中间件"><a href="#Express-内置的中间件" class="headerlink" title="Express 内置的中间件"></a>Express 内置的中间件</h4><ul><li>express.static()</li><li>express.json()解析JSON格式的请求数据</li><li>express.urlencoded()解析URL-encoded格式的请求体数据</li></ul><h4 id="第三方的中间件"><a href="#第三方的中间件" class="headerlink" title="第三方的中间件"></a>第三方的中间件</h4><h2 id="express写接口"><a href="#express写接口" class="headerlink" title="express写接口"></a>express写接口</h2><h3 id="CORS解决跨域问题"><a href="#CORS解决跨域问题" class="headerlink" title="CORS解决跨域问题"></a>CORS解决跨域问题</h3><ol><li><code>npm install cors</code></li><li><code>const cors = require(&#39;cors&#39;)</code>导入中间件</li><li>在路由之前调用<code>app.use(cors())</code>配置中间件</li></ol><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p><code>npm i mysql</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const mysql= require(&#x27;mysql&#x27;)</span><br><span class="line">const db = mysql.createPool(&#123;</span><br><span class="line">  host: &#x27;localhost&#x27;,</span><br><span class="line">  port: 3306,</span><br><span class="line">  user: &#x27;root&#x27;,</span><br><span class="line">  password: &#x27;123456&#x27;,</span><br><span class="line">  database: &#x27;itcase&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.query(&#x27;SELECT * FROM 表名&#x27;,(err,result)=&gt;&#123;</span><br><span class="line">  if(err) return console.log(err.message)</span><br><span class="line">  if (results.affectedRows === 1) &#123; console.log(&quot;更新成功！&quot;) &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><ul><li>方式一<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const sqlStr = &#x27;UPDATE student SET name=?,pwd=? WHERE id=?&#x27;</span><br><span class="line">  db.query(sqlStr, [user.name, user.pwd, user.id], (err, results) =&gt; &#123;</span><br><span class="line">  if (err) return console.log(err.message)</span><br><span class="line">  if (results.affectedRows === 1) &#123; console.log(&quot;更新成功！&quot;) &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></li><li>方式二<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123; id: 23, name: &#x27;wwww&#x27;, pwd: &#x27;666&#x27; &#125;</span><br><span class="line">const sqlStr = &#x27;UPDATE student SET ? WHERE id=?&#x27;</span><br><span class="line">db.query(sqlStr, [user, user.id], (err, results) =&gt; &#123;</span><br><span class="line">  if (err) return console.log(err.message)</span><br><span class="line">  if (results.affectedRows === 1) &#123; console.log(&quot;更新成功！&quot;) &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const sqlStr = &#x27;DELETE FROM student WHERE id=?&#x27;</span><br><span class="line">db.query(sqlStr, 23, (err, results) =&gt; &#123;</span><br><span class="line">  if (err) return console.log(err.message)</span><br><span class="line">  if (results.affectedRows === 1) &#123; console.log(&quot;删除成功&quot;) &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>标记删除<br>没有真正的删除，只是把状态更新为1<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const sqlStr = &#x27;UPDATE student SET status=? WHERE id=?&#x27;</span><br><span class="line">db.query(sqlStr,[1,6],(err,results)=&gt;&#123;</span><br><span class="line">  if (err) return console.log(err.message)</span><br><span class="line">  if (results.affectedRows === 1) &#123; console.log(&quot;标记删除成功&quot;) &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="session认证"><a href="#session认证" class="headerlink" title="session认证"></a>session认证</h2><p>cookie:键值对进行表示的(key-value)，例如name&#x3D;jack<br>Cookie就是一些数据，用于存储服务器返回给客服端的信息，客户端进行保存。在下一次访问该网站时，客户端会将保存的cookie一同发给服务器，服务器再利用cookie进行一些操作。利用cookie我们就可以实现自动登录，保存游览历史，身份验证等功能。(不安全)<br>session就是一个对象，用于存储信息。session是<font color="red">存储于服务器端</font>的特殊对象，服务器会为每一个游览器(客户端)创建一个唯一的session。这个session是服务器端共享，每个浏览器(客户端)独享的。我们可以在session存储数据，实现数据共享。<br><code>npm i express-session</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const session = require(&#x27;express-session&#x27;)//引入</span><br><span class="line">app.use(session(&#123;//注册为全局中间件</span><br><span class="line">  secret:&#x27;itheima&#x27;,</span><br><span class="line">  resave:false,</span><br><span class="line">  saveUninitialized:true</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><ul><li>向session中存数据<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.post(&#x27;/post&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html;charset=utf-8&#x27;);</span><br><span class="line">  if (req.body.username !== &#x27;admin&#x27; || req.body.password !== &#x27;000000&#x27;) &#123;</span><br><span class="line">    return res.send(&#123; status: 1, msg: &#x27;登陆失败&#x27; &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  req.session.user = req.body;</span><br><span class="line">  req.session.isLogin = true</span><br><span class="line">  res.send(&#123; status: 0, msg: &#x27;登陆成功&#x27; &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>从session 中取数据<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x27;/get&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  if (!req.session.isLogin) &#123;</span><br><span class="line">    return res.send(&#123; status: 1, msg: &#x27;fail&#x27; &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  res.send(&#123; status: 0, msg: &#x27;success&#x27;, username: req.session.username, &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>用于req.body获取值的<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var bodyParser = require(&#x27;body-parser&#x27;);</span><br><span class="line">app.use(bodyParser.json());</span><br></pre></td></tr></table></figure></li><li>清空当前用户的session，(退出登录等)<br><code>req.session.destory()</code></li></ul><p><strong>前端请求后端接口不存在跨域问题，推荐使用session身份认证</strong><br><strong>前端需要跨域请求后端接口时，推荐使用JWT认证机制</strong></p><h2 id="JWT-跨域认证方案"><a href="#JWT-跨域认证方案" class="headerlink" title="JWT 跨域认证方案"></a>JWT 跨域认证方案</h2><p>用户向服务器提交账号和密码,<font color="red">服务端</font>验证通过后，将用户的信息对象，经过加密后生成的Token字符串，(服务端不保留该字符串)，发送给客户端，<font color="red">客户端将Token存到LocalStorage或者SessionStorage中</font>，当客户端再次发送请求时，通过请求头的Authorization字段，将Token发送给服务器。服务器将Token字符串还原成用户的信息对象，认证成功后服务器响应特定的内容。</p><ul><li>jwt的组成部分 Header.Payload.Signature<br>Payload:真正的用户信息，用户信息加密后生成的字符串<br>Header,Signature:安全性相关的部分，为了保证Token的安全性</li></ul><h3 id="在Express中使用JWT"><a href="#在Express中使用JWT" class="headerlink" title="在Express中使用JWT"></a>在Express中使用JWT</h3><ol><li>安装相关的包<code>npm install jsonwebtoken express-jwt</code><br>jsonwebtoken:用于生成JWT字符串<br>express-jwt:将JWT字符串解析还原成JSON对象</li><li>导入包<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const jwt=require(&#x27;jsonwebtoken&#x27;)</span><br><span class="line">const expressJWT = require(&#x27;express-jwt&#x27;)</span><br></pre></td></tr></table></figure></li><li>定义secret密钥(对用户信息进行加密)，是一个字符串</li><li>生成JWT字符串：(调用sign方法)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const tokenStr = jwt.sign(&#123;name:userInfo.name&#125;,secretKey,&#123;expiresIn:&#x27;30s&#x27;&#125;)</span><br></pre></td></tr></table></figure>参数一：用户的信息对象<br>参数二：密钥<br>参数三：配置对象，可以配置当前token的有效期<br>然后通过响应头的token属性把tokenStr带上去</li><li>将JWT字符串还原为JSON对象，<strong>只要配置成功express-jwt中间件，就自动把解析出来的用户信息，挂载到req.auth属性上</strong><br><code>app.use(expressJWT.expressjwt(&#123; secret: secretKey, algorithms: [&#39;HS256&#39;] &#125;).unless(&#123; path: [/^\/api\//] &#125;))</code><br>&#x2F;正则&#x2F;,以&#x2F;api开头的都不需要访问权限<br>注意：<font color="red">密码不要加密到token字符串中！</font></li><li>获取用户信息<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x27;/admin/getInfo&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  console.log(req.auth)</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    status: 200,</span><br><span class="line">    message: &#x27;获取用户信息成功&#x27;,</span><br><span class="line">    data: req.auth,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>使用全局错误处理中间件；捕获解析JWT失败后产生的错误<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">app.use((err, req, res, next) =&gt; &#123;</span><br><span class="line">  if (err.name === &#x27;UnauthorizedError&#x27;) &#123;</span><br><span class="line">    return res.send(&#123;</span><br><span class="line">      stauts: 401,</span><br><span class="line">      message: &#x27;无效token&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    status: 500,</span><br><span class="line">    message: &#x27;未知错误&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h1 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h1><p>使用<code>bcryptjs</code>对密码进行加密</p><ul><li>加密之后，无法逆向破解</li><li>同一明文密码多次加密，得到的加密结果各不相同，保证了安全性</li></ul><ol><li><code>npm i bcryptjs</code></li><li>在<code>/router_handler/user.js</code>中，导入bcryptjs</li><li>调用<code>bcrypyjs.hashSync(明文密码，随机盐的长度)</code><br>第二个参数可以保证密码的安全性</li></ol><p><code>bcryptjs.compareSync(用户提交的密码，数据库的密码)</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2024/12/13/git/"/>
      <url>/2024/12/13/git/</url>
      
        <content type="html"><![CDATA[<p>工作区、暂存区、版本区，三个区共同组成了一个 Git 仓库</p><h1 id="基本操作流程"><a href="#基本操作流程" class="headerlink" title="基本操作流程"></a>基本操作流程</h1><ol><li>创建一个空文件夹（名称不要包含中文），随后双击打开文件夹。</li><li>在文件夹空白处右键启动命令行</li><li>创建一个 Git 仓库，<code>git init</code>(工作区)，可以创建一些文件，我们创建a.txt</li><li><code>git add a.txt</code>把工作区中【a.txt】添加到暂存区;<code>git add -A</code>可以把工作区中的所有文件，都添加到暂存区.</li><li>把暂存区a.txt添加到版本区，具体命令为：<code>git commit -m &#39;xxx&#39;</code></li></ol><h2 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h2><p><code>git status</code>或<code>git status -s</code></p><ul><li>On branch master(当前所在的分支)<br>nothing to commit, working tree clean(当前没有任何文件需要提交)<br><img src="/2024/12/13/git/image.png"><br>刚创建一个文件,还在工作区，没有接受版本控制。<br><img src="/2024/12/13/git/image%20copy.png"></li><li>红色的含义：操作停留在工作区</li><li>？的含义：当前文件还没有接受版本控制<br><code>git add</code>已经存入了暂存区<br><img src="/2024/12/13/git/image%20copy%202.png" alt="alt text"></li><li>绿色的含义：操作已经存入暂存区</li><li>A 的含义：新增（单词：add）<br>对文件进行修改<br><img src="/2024/12/13/git/image%20copy%203.png" alt="alt text"></li><li>M的含义：修改（单词： modify）</li></ul><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><ul><li>创建分支<code>git branch xxx</code>创建完分支后，tets 分支并不是空的，而且保留了 master 分支当前所有的提交记录。</li><li>使用<code>git branch</code>可以查看所有分支</li><li>使用<code>git checkout xxx</code>可以切换分支</li><li><code>git branch -d xxx</code>可用于删除一个分支</li></ul><h1 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a>Gitee</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li><p>维护好本地仓库（所有文件均接受版本控制<br>git add xxxx<br>git commit -m ‘注释’</p></li><li><p>配置本地仓库关联远程仓库：<br>git remote add origin <a href="https://xxxx/xxxx/xxxxx.git">https://xxxx/xxxx/xxxxx.git</a></p><ul><li>查看当前仓库关联远程仓库地址：git remote -v</li><li>更改远程仓库的 URL：git remote set-url origin 新的仓库URL</li><li>删除与远程仓库的关联：git remote remove origin</li></ul></li><li><p>将本地仓库的 master 分支推送到远程仓库<br><code>git push -u origin master</code></p></li><li><p>当本地仓库想获得远程仓库的最新修改时，可以使用git pull命令拉取远端代码。<br><code>git pull</code></p></li></ul><h2 id="克隆远程库"><a href="#克隆远程库" class="headerlink" title="克隆远程库"></a>克隆远程库</h2><p>获取一个远程仓库的地址，随后执行克隆命令<br><code>git clone https://xxxx/xxxx/xxxx.git</code><br>使用–depth 1 参数可以克隆仓库的最近一次提交，这样可以减少克隆所需的时间和空间。<br><code>git clone --depth 1 https://xxxx/xxxx/xxxx.git</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>跨域问题</title>
      <link href="/2024/12/13/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2024/12/13/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="关于跨域"><a href="#关于跨域" class="headerlink" title="关于跨域"></a>关于跨域</h1><h2 id="源：协议-域名-端口号"><a href="#源：协议-域名-端口号" class="headerlink" title="源：协议+域名+端口号"></a>源：协议+域名+端口号</h2><p>浏览器会对跨域做出哪些限制？</p><ol><li>dom访问限制</li><li>cookie访问限制</li><li>Ajax 响应数据限制<br><font color="red">注意</font></li></ol><ul><li>跨域限制仅存在浏览器端，服务端不存在跨域限制</li><li>即使跨域了，Ajax 请求也可以正常发出，但响应数据不会交给开发者。<br>  <img src="/2024/12/13/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image.png"></li><li><code>&lt;link&gt;</code> <code>&lt;script&gt;</code> <code>&lt;img&gt;</code>  ….. 这些标签发出的请求也可能跨域，只不过浏览器对标签跨域不做严格限制，对开发几乎无影响。</li></ul><h1 id="CORS解决跨域问题"><a href="#CORS解决跨域问题" class="headerlink" title="CORS解决跨域问题"></a>CORS解决跨域问题</h1><p>CORS 全称：Cross-Origin Resource Sharing（跨域资源共享），是用于控制浏览器校验跨域请求的一套规范，服务器依照 CORS 规范，添加特定响应头来控制浏览器校验，大致规则如下：</p><ul><li><font color="red">服务器</font>明确表示拒绝跨域请求，或没有表示，则浏览器校验不通过。</li><li><font color="red">服务器</font>明确表示允许跨域请求，则浏览器校验通过。</li></ul><h2 id="解决简单请求跨域"><a href="#解决简单请求跨域" class="headerlink" title="解决简单请求跨域"></a>解决简单请求跨域</h2><p>服务器在给出响应时，通过添加Access-Control-Allow-Origin响应头，来明确表达允许某个源发起跨域请求，随后浏览器在校验时，直接通过。<br>服务端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 处理跨域中间件</span><br><span class="line">function corsMiddleWare(req,res,next)&#123;</span><br><span class="line">  // 允许 http://127.0.0.1:5500 这个源发起跨域请求</span><br><span class="line">  // res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;http://127.0.0.1:5500&#x27;)</span><br><span class="line">  </span><br><span class="line">  // 允许所有源发起跨域请求</span><br><span class="line">  res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;)</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 配置路由并使用中间件</span><br><span class="line">app.get(&#x27;/&#x27;,corsMiddleWare,(req,res)=&gt;&#123;</span><br><span class="line">  res.send(&#x27;hello!&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="简单请求与复杂请求"><a href="#简单请求与复杂请求" class="headerlink" title="简单请求与复杂请求"></a>简单请求与复杂请求</h3><table><thead><tr><th>简单请求</th><th>复杂请求</th></tr></thead><tbody><tr><td>请求方法为：GET、HEAD、POST</td><td></td></tr><tr><td>请求头字段要符合规范（不手动改请求头一般都符合规范</td><td></td></tr><tr><td>请求头的Content-Type的值只能是以下三种：text&#x2F;plain,multipart&#x2F;form-data,application&#x2F;x-www-form-urlencoded</td><td></td></tr></tbody></table><p>复杂请求会自动发送预检请求</p><h3 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h3><ol><li>在实际跨域请求之前发出</li><li>用于向服务器确认是否允许接下来的跨域请求。</li><li>基本流程：先发起OPTIONS请求，如果通过预检，继续发起实际的跨域请求。</li><li>OPTIONS请求头内容：<table><thead><tr><th>请求头</th><th>含义</th></tr></thead><tbody><tr><td>Origin</td><td>发起请求的源</td></tr><tr><td>Access-Control-Request-Method</td><td>实际请求的 HTTP 方法</td></tr><tr><td>Access-Control-Request-Headers</td><td>实际请求中使用的自定义头（如果有的话）</td></tr></tbody></table></li></ol><h2 id="解决复杂请求跨域"><a href="#解决复杂请求跨域" class="headerlink" title="解决复杂请求跨域"></a>解决复杂请求跨域</h2><ol><li>服务器先通过浏览器的预检请求，服务器需要返回如下响应头</li></ol><ul><li>Access-Control-Allow-Origin允许的源</li><li>Access-Control-Allow-Methods允许的方法</li><li>Access-Control-Allow-Headers允许的自定义头</li><li>Access-Control-Max-Age预检请求的结果缓存时间（可选）如果加上，就表示在多少秒内不再发送预检请求，否则多次点击时会重复发送</li></ul><ol start="2"><li><h2 id="处理实际的跨域请求（借助cors库完成配置）-npm-i-cors-app-use-cors"><a href="#处理实际的跨域请求（借助cors库完成配置）-npm-i-cors-app-use-cors" class="headerlink" title="处理实际的跨域请求（借助cors库完成配置）- npm i cors- app.use(cors())"></a>处理实际的跨域请求（借助cors库完成配置）<br>- <code>npm i cors</code><br>- <code>app.use(cors())</code></h2>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const corsOptions = &#123;</span><br><span class="line">origin: &#x27;http://127.0.0.1:5500&#x27;, // 允许的源</span><br><span class="line">methods: [&#x27;GET&#x27;, &#x27;POST&#x27;, &#x27;PUT&#x27;, &#x27;DELETE&#x27;, &#x27;HEAD&#x27;, &#x27;OPTIONS&#x27;], // 允许的方法</span><br><span class="line">allowedHeaders: [&#x27;school&#x27;], // 允许的自定义头</span><br><span class="line">exposedHeaders: [&#x27;abc&#x27;], // 要暴露的响应头（允许浏览器端拿到该响应头，不加就无法获取）</span><br><span class="line">optionsSuccessStatus: 200 // 预检请求成功的状态码</span><br><span class="line">&#125;;</span><br><span class="line">app.use(cors(corsOptions)); // 使用cors中间件</span><br></pre></td></tr></table></figure></li></ol><h1 id="配置代理服务器解决跨域"><a href="#配置代理服务器解决跨域" class="headerlink" title="配置代理服务器解决跨域"></a>配置代理服务器解决跨域</h1><p>借助<code>http-proxy-middleware</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const &#123; createProxyMiddleware &#125; = require(&#x27;http-proxy-middleware&#x27;);</span><br><span class="line"></span><br><span class="line">app.use(&#x27;/api&#x27;,createProxyMiddleware(&#123;</span><br><span class="line">  target:&#x27;https://www.toutiao.com&#x27;,</span><br><span class="line">  changeOrigin:true,</span><br><span class="line">  pathRewrite:&#123;</span><br><span class="line">    &#x27;^/api&#x27;:&#x27;&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>解释：<br>自己给自己发请求(‘<a href="https://127.0.0.1:8080/api/news/today')%EF%BC%8C%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8B%A6%E6%88%AA%E6%89%80%E6%9C%89%E5%B8%A6%E6%9C%89/api%E7%9A%84%E8%AF%B7%E6%B1%82%EF%BC%8C%EF%BC%88target%EF%BC%89%E8%BD%AC%E5%8F%91%E7%BB%99'https://www.toutiao.com'%EF%BC%8C%EF%BC%88pathRewrite%EF%BC%89%E8%BD%AC%E5%8F%91%E6%97%B6%E5%B0%86/api%E6%9B%BF%E6%8D%A2%E4%B8%BA%E7%A9%BA('https://www.toutiao.com/news/today')">https://127.0.0.1:8080/api/news/today&#39;)，代理服务器拦截所有带有/api的请求，（target）转发给&#39;https://www.toutiao.com&#39;，（pathRewrite）转发时将/api替换为空(&#39;https://www.toutiao.com/news/today&#39;)</a>;<br>此时，发出请求的是代理服务器，而服务器之间没有跨域限制;<br>浏览器&lt;-&gt;代理服务器&lt;-&gt;目标服务器<br>所以我们还要保证浏览器和代理服务器之间不能存在跨域问题。<br>把一个网页和代理服务器捆绑（同源）：在server.js中<code>app.use(express.static(&#39;./index.html&#39;))</code>–&gt;把静态页面给服务器，此时只需要访问代理服务器的端口号即可访问到该静态页面</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java</title>
      <link href="/2024/12/09/java/"/>
      <url>/2024/12/09/java/</url>
      
        <content type="html"><![CDATA[<h1 id="环境变量的配置"><a href="#环境变量的配置" class="headerlink" title="环境变量的配置"></a>环境变量的配置</h1><ol><li>先配置JAVA_HOME （路径不带bin）</li><li>再配置Path (%JAVA_HOME%\bin)</li></ol><h1 id="JRE与JDK"><a href="#JRE与JDK" class="headerlink" title="JRE与JDK"></a>JRE与JDK</h1><p>JDK:java开发工具包，包括JVM虚拟机：JAVA程序运行的地方；核心类库；开发工具：javac,java…<br>JRE:java运行环境；包括：JVM,核心类库，运行工具<br>JDK包含JRE包含JVM</p><h1 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h1><p>|整数|小数|字符串|字符|布尔|空|<br>‘\t’，把前面的字符串补成8位或8的倍数<br>基本数据类型</p><table><thead><tr><th align="center">整数</th><th align="center">浮点数</th><th align="center">字符</th><th align="center">布尔</th></tr></thead><tbody><tr><td align="center">byte,short,int,long</td><td align="center">float,double</td><td align="center">char</td><td align="center">boolean</td></tr></tbody></table><p>取值范围:double&gt;float&gt;long&gt;int&gt;short&gt;byte<br><code>long l = 99999999L;</code><br><code>float f=10.2F;</code><br><code>double d = 20.2;</code></p><h1 id="idea-项目结构"><a href="#idea-项目结构" class="headerlink" title="idea 项目结构"></a>idea 项目结构</h1><p>project–&gt;module–&gt;package–&gt;class<br>包： 文件夹，用来管理不同功能的java类<br>包名一般是公司域名的倒写。例如：黑马是<a href="http://www.itheima.com,包名就可以定义成com.itheima.技术名称./">www.itheima.com,包名就可以定义成com.itheima.技术名称。</a></p><h1 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h1><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><ol><li>int+double，int 会先提升为double 再计算</li><li>short,char,byte会先提升为int 再计算，byte+byte&#x3D;int</li></ol><h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>1+2+”abc”+2+1–&gt;”3abc21”<br>^（异或）的使用：计算规则：如果两边相同，结果为false，如果两边不同，结果为true</p><p>&amp;&amp; 和 &amp; 、||和|的运行结果都是一模一样的。但是短路逻辑运算符可以提高程序的运行效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">switch</span> (number) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> -&gt; System.out.println(<span class="string">&quot;一&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> -&gt; System.out.println(<span class="string">&quot;二&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span> -&gt; System.out.println(<span class="string">&quot;三&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;其他&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导包</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//2.创建对象</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="comment">//3.生成随机数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> r.nextInt(<span class="number">100</span>);<span class="comment">//包左不包右，包头不包尾</span></span><br><span class="line">        <span class="comment">//0 ~ 99</span></span><br><span class="line">        System.out.println(number);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>int 类型的数组可以存：byte类型，short类型。<br>利用静态初始化完成创建并添加元素<br>int[] agesArr &#x3D; new int[]{18,19,20,21,22};<br>int[] agesArr &#x3D; {18,19,20,21,22};</p><p>动态初始化：<br>1.定义一个数组，存3个人的年龄，年龄未知<br>int[] agesArr &#x3D; new int[3];<br>2.定义一个数组，存班级10名学生的考试成绩，考试成绩暂时未知，考完才知道。<br>int[] scoresArr &#x3D; new int[10];<br><strong>数组一旦创建之后，长度不能发生变化。</strong><br>数组的默认初始化值：<br>整数类型：0<br>小数类型：0.0<br>布尔类型：false<br>字符类型：’\u0000’<br>引用类型：null</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static 返回值类型 方法名(参数) &#123;</span><br><span class="line">   方法体; </span><br><span class="line">   return 数据 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>满足下列条件的多个方法相互构成重载:</p><ol><li>多个方法在同一个类中</li><li>多个方法具有相同的方法名</li><li>多个方法的参数不相同，类型不同或者数量不同<br><strong>不能通过返回值来判定两个方法是否相互构成重载</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MethodDemo &#123;</span><br><span class="line">public static void fn(int a) &#123;</span><br><span class="line">    //方法体</span><br><span class="line">    &#125;</span><br><span class="line">    public static int fn(double a) &#123;</span><br><span class="line">    //方法体</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MethodDemo &#123;</span><br><span class="line">public static float fn(int a) &#123;</span><br><span class="line">    //方法体</span><br><span class="line">    &#125;</span><br><span class="line">    public static int fn(int a , int b) &#123;</span><br><span class="line">    //方法体</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>没有返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class 类名&#123;</span><br><span class="line">​ 修饰符 类名( 参数 ) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法的创建<br>如果没有定义构造方法，系统将给出一个默认的无参数构造方法<br>如果定义了构造方法，系统将不再提供默认的构造方法<br>构造方法的重载<br>如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法<br>推荐的使用方式<br>无论是否使用，都手工书写无参数构造方法<br>重要功能！<br>可以使用带参构造，为成员变量进行初始化<br><img src="/2024/12/09/java/image-1.png" alt="alt text"><br>基本数据类型：数据值存储在自己的空间中<br>引用数据类型：例如上图中，s1存放的是数据值的地址，需要在该地址才能找到对应的数据，所以叫引用数据类型；</p><h1 id="键盘录入"><a href="#键盘录入" class="headerlink" title="键盘录入"></a>键盘录入</h1><p>遇到空格，制表符，回车就停止接收</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">int num1=sc.nextInt();//接收整数</span><br><span class="line">double num2=sc.nextDouble();//浮点数</span><br><span class="line">String num3=sc.next();//字符串</span><br></pre></td></tr></table></figure><p>可以接收空格，制表符，遇到回车才停止</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String n4 = sc.nextLine();//字符串</span><br></pre></td></tr></table></figure><h1 id="String类的构造方法"><a href="#String类的构造方法" class="headerlink" title="String类的构造方法"></a>String类的构造方法</h1><p>两种方式：1.直接赋值 2.new</p><ul><li><p>常用的构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>String s &#x3D; String()</td><td>创建一个空白字符串对象，不含有任何内容</td></tr><tr><td>char[] chs&#x3D;{‘1’,’a’};String s4 &#x3D; new String(chs);</td><td>根据字符数组的内容，来创建字符串对象</td></tr><tr><td>public   String(byte[] bys)</td><td>根据字节数组的内容，来创建字符串对象</td></tr><tr><td>String s &#x3D;   “abc”;</td><td>直接赋值的方式创建字符串对象，内容就是abc</td></tr></tbody></table></li><li><p>两种构建方式在内存中的区别<br>通过构造方法创建：通过 new 创建的字符串对象，每一次 new 都会在堆中申请一个内存空间，虽然内容相同，但是地址值不同<br>直接赋值方式创建：以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护<br><img src="/2024/12/09/java/image-2.png" alt="alt text"></p></li><li><p>&#x3D;&#x3D;号比较的</p></li></ul><ol><li>基本数据类型：数据值</li><li>引用数据类型：地址值</li></ol><ul><li>equals()，equalsIgnoreCase()</li><li>substring(),replace<br>StringBuilder()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder ab = new StringBuilder(&quot;abc&quot;);</span><br><span class="line">System.out.println(ab);</span><br><span class="line">ab.append(&quot;cd&quot;);</span><br><span class="line">System.out.println(ab.reverse());</span><br><span class="line">System.out.println(ab.length());</span><br><span class="line">System.out.println(ab.toString());</span><br></pre></td></tr></table></figure>StringJoiner<br>StringJoiner跟StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的。<br>作用：提高字符串的操作效率，而且代码编写特别简洁，但是目前市场上很少有人用。<br>JDK8出现的<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//1.创建一个对象，并指定中间的间隔符号</span><br><span class="line">StringJoiner sj = new StringJoiner(&quot;---&quot;);</span><br><span class="line">//2.添加元素</span><br><span class="line">sj.add(&quot;aaa&quot;).add(&quot;bbb&quot;).add(&quot;ccc&quot;);</span><br><span class="line">//3.打印结果</span><br><span class="line">System.out.println(sj);//aaa---bbb---ccc</span><br></pre></td></tr></table></figure></li></ul><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><ul><li><p>什么是集合</p><p>​提供一种存储空间可变的存储模型，存储的数据容量可以发生改变</p></li><li><p>ArrayList集合的特点</p><p>​长度可以变化，只能存储<font color="red">引用数据类型</font>。</p></li><li><p>泛型的使用</p><p>​用于约束集合中存储元素的数据类型</p></li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public boolean add(要添加的元素)</td><td>将指定的元素追加到此集合的末尾</td></tr><tr><td>public boolean remove(要删除的元素)</td><td>删除指定元素,返回值表示是否删除成功</td></tr><tr><td>public E  remove(int   index)</td><td>删除指定索引处的元素，<strong>返回被删除的元素</strong></td></tr><tr><td>public E   set(int index,E   element)</td><td>修改指定索引处的元素，<strong>返回被修改的元素</strong></td></tr><tr><td>public E   get(int   index)</td><td>返回指定索引处的元素</td></tr><tr><td>public int   <strong>size()</strong></td><td>返回集合中的元素的个数</td></tr></tbody></table><h1 id="静态static"><a href="#静态static" class="headerlink" title="静态static"></a>静态static</h1><p><img src="/2024/12/09/java/image-3.png" alt="alt text"><br>静态成员变量:修饰符 static 数据类型 变量名 &#x3D; 初始值；<br>当 <code>static</code> 修饰成员变量或者成员方法时，该变量称为<strong>静态变量</strong>，该方法称为<strong>静态方法</strong>。该类的每个对象都<strong>共享</strong>同一个类的静态变量和静态方法。任何对象都可以更改该静态变量的值或者访问静态方法。因为静态变量或者静态方法直接<strong>通过类名访问</strong>即可.<br>static修饰的成员属于类，会存储在静态区，是随着类的加载而加载的，且只加载一次，所以只有一份，节省内存。存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。它优先于对象存在，所以，可以被所有对象共享。<br>总结：</p><ol><li>静态方法中，只能访问静态</li><li>非静态可以访问所有</li><li>静态中没有this关键字</li></ol><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ol><li>java只能单继承，一个类只能继承一个直接父类</li><li>java不支持多继承，但是支持多层继承</li><li>java中所有的类都直接或间接继承于Object类</li><li>子类不能访问父类中私有的</li></ol><ul><li>子类可以继承父类中的哪些内容？</li></ul><ol><li>父类的构造方法不能被子类继承</li><li>成员变量 非私有：可以；private：可以，但不可以直接使用。</li><li>成员方法： 虚方法表（非private,static,final）中的可以，其他不可以。</li></ol><h2 id="继承中成员变量的访问特点"><a href="#继承中成员变量的访问特点" class="headerlink" title="继承中成员变量的访问特点"></a>继承中成员变量的访问特点</h2><ol><li>就近原则：局部-&gt;本类成员变量-&gt;父类成员变量（逐级往上</li><li>如果出现重名 父类中的可以用super.name访问，this(就近原则),super(直接找父类)</li></ol><ul><li>方法的重写：当父类中的方法不能满足需求时<br>只有被添加到<strong>虚方法表</strong>中的方法才能被重写且重写的方法尽可能和父类保持一致</li></ul><h2 id="父类中的构造方法访问特点"><a href="#父类中的构造方法访问特点" class="headerlink" title="父类中的构造方法访问特点"></a>父类中的构造方法访问特点</h2><ul><li>父类中的构造方法不会被子类继承        </li><li>子类中所有的构造方法默认先访问父类中的无参构造，再执行自己<br>为什么？ 子类在初始化时有可能会用到父类中的数据，如果父类没有完成初始化，子类无法使用父类的数据；那么如何调用父类构造方法的？子类构造方法第一行语句默认都是super()，不写也存在，且必须在第一行。如果想调用父类有参构造，必须手动写super调用。<br><img src="/2024/12/09/java/image-4.png" alt="alt text"></li></ul><h1 id="多态（对象的多种形态"><a href="#多态（对象的多种形态" class="headerlink" title="多态（对象的多种形态"></a>多态（对象的多种形态</h1><ol><li>多态的前提？</li></ol><ul><li>有继承&#x2F;实现关系</li><li>父类的引用指向子类对象</li><li>方法的重写<br><img src="/2024/12/09/java/image-5.png" alt="alt text"><br>调用成员变量：编译看左边（父类，运行也看左边<br>调用成员方法：编译看左边，运行看右边（子类</li><li>优势<br>方法中，使用父类型作为参数，可以接收所有子类对象</li><li>弊端：不能使用子类的特有功能</li><li>解决方案：类型转换：自动类型转换(Person p &#x3D; new Student()) 强制类型转换Student s &#x3D; (Student)p,如果转换类型不一致，可以用以下两种方法进行判断<br><img src="/2024/12/09/java/image-6.png" alt="alt text"> <img src="/2024/12/09/java/image-7.png" alt="alt text"></li></ul><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><ul><li>类：被修饰的类，不能被继承。</li><li>方法：被修饰的方法，不能被重写。</li><li>变量：被修饰的变量，有且仅能被赋值一次。</li></ul><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><ul><li>单个单词：全部大写</li><li>多个单词：全部大写，单词间用下划线隔开<br><strong>注意</strong></li></ul><ol><li>final 修饰的变量是基本类型：变量存储的<strong>数据值</strong>不能发生改变</li><li>final 修饰的变量是引用类型：变量存储的<strong>地址值</strong>不能发生改变，对象内部可以改变<br>String 不能修改：private final void String -&gt;final说明无法修改地址，pravite 不能修改地址值（不提供get和set方法</li></ol><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p><img src="/2024/12/09/java/image-8.png" alt="alt text"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块：在方法中的代码块</li><li>构造代码块：{}写在成员变量位置的代码块<ul><li>作用：可以把多个构造方法中重复的代码抽取出来</li><li>执行时机：创建本类实例对象时，会先执行构造代码块再执行构造方法</li></ul></li><li><strong>静态代码块</strong> static{} 随着类的加载而加载，自动触发，只执行一次（用于初始化对象）</li></ol><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p><blockquote><p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p></blockquote></li><li><p>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p><blockquote><p>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</p></blockquote></li><li><p>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p><blockquote><p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p></blockquote></li><li><p>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则子类也必须定义成抽象类，编译无法通过而报错。 </p><blockquote><p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p></blockquote></li><li><p>抽象类存在的意义是为了被子类继承。</p></li></ol><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul><li>成员变量：只能是常量，默认修饰符：public static final</li><li>构造方法：没有</li><li>成员方法：只能是抽象方法，默认修饰符：public abstract</li></ul><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ul><li>类和类：继承关系，只能单继承，不能多继承，但是可以多层继承</li><li>类和接口：实现关系，可以单实现也可以多实现，还可以在继承一个类的同时实现多个接口</li><li>接口和接口，继承关系，可以单继承，也可以多继承</li></ul><h2 id="接口中的默认方法"><a href="#接口中的默认方法" class="headerlink" title="接口中的默认方法"></a>接口中的默认方法</h2><ul><li>默认方法不强制被重写，如果被重写，去掉default关键字</li><li>public可以省略，default不能省</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类必须重写该方法</li></ul><h2 id="接口中静态方法"><a href="#接口中静态方法" class="headerlink" title="接口中静态方法"></a>接口中静态方法</h2><ul><li>public static void 方法名(){}</li><li>静态方法只能通过接口名调用，不能通过实现类名或者对象名调用</li><li>public可以省略，static不能省，静态方法不能被重写</li></ul><p><img src="/2024/12/09/java/image-9.png" alt="alt text"><br><img src="/2024/12/09/java/image-10.png" alt="alt text"></p><p><img src="/2024/12/09/java/image-11.png" alt="alt text"></p><h1 id="JLabel"><a href="#JLabel" class="headerlink" title="JLabel"></a>JLabel</h1><p>一个组件，用于显示一段短文本或一个图像图标。</p><ul><li>JLabel jlabel &#x3D; new JLabel(Icon image)：创建一个带有指定图像的标签。</li><li>JLabel jlabel &#x3D; new JLabel(String text)：创建一个带有指定文本的标签。</li><li>ImageIcon i &#x3D; new ImageIcon(“path&#x2F;to&#x2F;image.png”);<br>JLabel l &#x3D; new JLabel(i);</li><li>jlabel.setBounds(203,283,197,73);&#x2F;&#x2F;设置在组件中显示的位置(x,y)，宽，高，</li><li>getContentPane().add(jlabel);获取面板内容并添加</li><li>ImageIcon image&#x3D;new ImageIcon(path);</li><li>image.setImage(image.getImage().getScaledInstance(105, 105, Image.SCALE_DEFAULT ));设置图片大小</li><li>System.exit(0);关闭虚拟机</li></ul><h1 id="JFrame类的方法"><a href="#JFrame类的方法" class="headerlink" title="JFrame类的方法"></a>JFrame类的方法</h1><p>setSize(488,430);<br>setTitle(“拼图单机版–登录”);<br>&#x2F;&#x2F;置顶<br>setAlwaysOnTop(true);<br>&#x2F;&#x2F;居中<br>setLocationRelativeTo(null);<br>&#x2F;&#x2F;设置关闭模式<br>setDefaultCloseOperation(3);<br>setVisible(true);</p><h1 id="常见API"><a href="#常见API" class="headerlink" title="常见API"></a>常见API</h1><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> a)</span><span class="comment">// 返回参数的绝对值</span></span><br><span class="line">Math.absExact()<span class="comment">//越界会报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">ceil</span><span class="params">(<span class="type">double</span> a)</span><span class="comment">// 向x正方向</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">floor</span><span class="params">(<span class="type">double</span> a)</span><span class="comment">// 向x负方向</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">round</span><span class="params">(<span class="type">float</span> a)</span><span class="comment">// 四舍五入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">// 获取两个int值中的较大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">// 获取两个int值中的较小值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">pow</span> <span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span><span class="comment">// 计算a的b次幂的值</span></span><br><span class="line">Math.sqrt ()</span><br><span class="line">Math.cbrt ()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">random</span><span class="params">()</span><span class="comment">// 返回一个[0.0,1.0)的随机值</span></span><br></pre></td></tr></table></figure><h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">currentTimeMillis</span><span class="params">()</span><span class="comment">// 获取当前时间所对应的毫秒值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span><span class="comment">// 终止当前正在运行的Java虚拟机，0表示正常退出，非零表示异常退出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src,  <span class="type">int</span>  srcPos, Object dest, <span class="type">int</span> destPos, <span class="type">int</span> length)</span>; <span class="comment">// 进行数值元素copy</span></span><br></pre></td></tr></table></figure><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span><span class="comment">//返回该对象的字符串表示形式(可以看做是对象的内存地址值)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span><span class="comment">//比较两个对象地址值是否相等；true表示相同，false表示不相同</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span>    <span class="comment">//对象克隆</span></span><br></pre></td></tr></table></figure><p><img src="/2024/12/09/java/image.png"><br>Object中的克隆，是浅克隆<br>浅克隆：不管是什么数据类型，都完全拷贝过来<br>深克隆：基本数据类型拷贝过来，字符串会被复用，引用数据类型会创建新的</p><h2 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h2><p><img src="/2024/12/09/java/image-12.png" alt="alt text"></p><h2 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h2><ul><li>获取到BigInteger对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BigInteger</span><span class="params">(<span class="type">int</span> num, Random rnd)</span> <span class="comment">//获取随机大整数，范围：[0 ~ 2的num次方-1]</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BigInteger</span><span class="params">(String val)</span> <span class="comment">//获取指定的大整数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BigInteger</span><span class="params">(String val, <span class="type">int</span> radix)</span> <span class="comment">//获取指定进制的大整数</span></span><br><span class="line">下面这个不是构造，而是一个静态方法获取BigInteger对象</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title function_">valueOf</span><span class="params">(<span class="type">long</span> val)</span> <span class="comment">//静态方法获取BigInteger的对象，内部有优化:-16到16之间是已经创造好的对象</span></span><br></pre></td></tr></table></figure></li><li>常用的方法</li></ul><p><img src="/2024/12/09/java/image%20copy%202.png" alt="alt text"></p><h2 id="bigDecimal"><a href="#bigDecimal" class="headerlink" title="bigDecimal"></a>bigDecimal</h2><p>创建对象：</p><ol><li>如果表示的数字不大，没有超出double的取值范围，用静态方法<code>BigDecimal bd1 = new BigDecimal(0.01)</code></li><li>如果表示的数字不大，超出double的取值范围,<code>BigDecimal bd1 = new BigDecimal(&quot;0.01&quot;)</code></li><li>如果传递的[0,10]之间的数方法会返回已经创建好的对象<code>BigDecimal bd1 = BigDecimal.valueOf(10)</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">add</span><span class="params">(BigDecimal value)</span><span class="comment">// 加法运算</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">subtract</span><span class="params">(BigDecimal value)</span><span class="comment">// 减法运算</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">multiply</span><span class="params">(BigDecimal value)</span><span class="comment">// 乘法运算</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">divide</span><span class="params">(BigDecimal value)</span><span class="comment">// 触发运算</span></span><br></pre></td></tr></table></figure><p><img src="/2024/12/09/java/image-13.png" alt="alt text"><br>| 或者<br>注意：(正则表达式的字母是一个一个匹配的)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;ab&quot;.matches(&quot;[abc]&quot;));//false</span><br><span class="line">System.out.println(&quot;ab&quot;.matches(&quot;[abc][abc]&quot;));//true</span><br><span class="line">System.out.println(&quot;zz&quot;.matches(&quot;[^abc]&quot;));//false</span><br><span class="line">System.out.println(&quot;zz&quot;.matches(&quot;[^abc][^abc]&quot;));//true</span><br><span class="line">regex4 = &quot;(?i)abc&quot;//忽略abc的大小写</span><br></pre></td></tr></table></figure><p><img src="/2024/12/09/java/image%20copy%203.png" alt="alt text"><br><img src="/2024/12/09/java/image%20copy%204.png" alt="alt text"><br><img src="/2024/12/09/java/image%20copy%205.png" alt="alt text"></p><h2 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Java是觉得今年圣诞节那就是&quot;</span>;</span><br><span class="line"><span class="comment">//Pattern 表示正则表达式</span></span><br><span class="line"><span class="comment">//Matcher 文本匹配器；作用：按照正则表达式的规则去读取字符串，从头开始读取；在大串中去找符合匹配规则的子串。</span></span><br><span class="line"><span class="comment">//获取正则表达式的对象</span></span><br><span class="line"><span class="comment">//找JavaXX</span></span><br><span class="line"><span class="comment">//p：规则</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;Java\\d&#123;0,2&#125;&quot;</span>);</span><br><span class="line"><span class="comment">//获取文本匹配器的对象</span></span><br><span class="line"><span class="comment">//m 要在str中找符合p规则的小串</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(str);</span><br><span class="line"><span class="comment">//拿着文本匹配器从头开始读取，寻找是否有满足规则的子串</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> m.find();</span><br><span class="line"><span class="comment">//如果没有返回false</span></span><br><span class="line"><span class="comment">//如果有，返回true.在底层记录字串的起始索引和结束索引+1</span></span><br><span class="line"><span class="comment">//subString(起始索引,结束索引) 包头不包尾</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> m.group();<span class="comment">//把截取的小串返回</span></span><br></pre></td></tr></table></figure><p>步骤：</p><ol><li>获取正则对象<code>Pattern p = Pattern.compile(&quot;Java\\d&#123;0,2&#125;&quot;);</code></li><li>获取文本匹配器对象<code>Matcher m = p.matcher(str);</code></li><li>查找<code>Boolean b = m.find();</code></li></ol><h3 id="特殊要求的爬取："><a href="#特殊要求的爬取：" class="headerlink" title="特殊要求的爬取："></a>特殊要求的爬取：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">&quot;java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和JAva11，&quot;</span> +</span><br><span class="line"><span class="string">&quot;因为这两个是长期支持版本，下一个长期支持版本是JAVa17，相信在未来不久JAVA17也会逐渐登上历史舞台&quot;</span>;</span><br><span class="line">Pattern p= Pattern.compile(regex1);</span><br><span class="line">Matcher m=p.matcher(str);</span><br><span class="line"><span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">System.out.println(m.group());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需求1:爬取版本号为8，11.17的Java文本，但是只要Java，不显示版本号。<font color="red"><strong>获取时只获取前半部分</strong></font><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String regex1=<span class="string">&quot;((?i)java)(?=8|11|17)&quot;</span>;</span><br></pre></td></tr></table></figure>其中&#x3D;表示java后面跟的东西，?是占位符，这里指Java</li><li>需求2:爬取版本号为8，11，17的Java文本。正确爬取结果为:Java8 Java11 Java17 Java17<font color="red"><strong>?:获取整体</strong></font><br><code>String regex1=&quot;((?i)java)(8|11|17)&quot;;</code>或<code>String regex1=&quot;((?i)java)(?:8|11|17)&quot;;</code></li><li>需求3:爬取除了版本号为8，11，17的Java文本，<br><code>String regex1=&quot;((?i)java)(?!8|11|17)&quot;;</code></li></ul><h3 id="贪婪爬取与非贪婪"><a href="#贪婪爬取与非贪婪" class="headerlink" title="贪婪爬取与非贪婪"></a>贪婪爬取与非贪婪</h3><p>java默认的就是贪婪爬取，只写+和*表示贪婪匹配，如果在+和后面加问号表示非贪婪爬取</p><h3 id="split和replaceAll方法"><a href="#split和replaceAll方法" class="headerlink" title="split和replaceAll方法"></a>split和replaceAll方法</h3><p><code>public String replaceAll(String regex,String newStr)</code><br>参数regex表示一个正则表达式。可以将当前字符串中匹配regex正则表达式的字符串替换为newStr。<br><code>public String[] split(String regex)</code><br>参数regex表示正则表达式。可以将当前字符串中匹配regex正则表达式的符号作为”分隔符”来切割字符串。</p><h3 id="捕获分组和非捕获分组"><a href="#捕获分组和非捕获分组" class="headerlink" title="捕获分组和非捕获分组"></a>捕获分组和非捕获分组</h3><h4 id="捕获分组"><a href="#捕获分组" class="headerlink" title="捕获分组"></a>捕获分组</h4><p><strong>后续还需要使用本组的数据</strong><br>形式：正则内部\组号  正则外部$组号</p><ul><li>一个字符<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">&quot;a123a&quot;</span>;</span><br><span class="line">String regex1=<span class="string">&quot;(.).+\\1&quot;</span>;</span><br><span class="line">System.out.println(str.matches(regex1));</span><br></pre></td></tr></table></figure></li><li>多个字符<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">&quot;ab123ab&quot;</span>;</span><br><span class="line">String regex1=<span class="string">&quot;(.+).+\\1&quot;</span>;</span><br><span class="line">System.out.println(str.matches(regex1));</span><br></pre></td></tr></table></figure></li><li>开始的每一个字符一样并且和后面的相同<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">&quot;aab123aaa&quot;</span>;<span class="comment">//注意此时的输出应为true,因为b和123被分为一组</span></span><br><span class="line">String regex1=<span class="string">&quot;((.)\\2*).+\\1&quot;</span>;</span><br><span class="line">System.out.println(str.matches(regex1));</span><br></pre></td></tr></table></figure></li><li>去除重复的(在正则外面使用分组)<br>将”我要学学学”替换为”我要学”<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">&quot;我要学学学&quot;</span>;</span><br><span class="line">String res=str.replaceAll(<span class="string">&quot;(.)\\1+&quot;</span>,<span class="string">&quot;$1&quot;</span>);</span><br><span class="line">System.out.println(res);</span><br></pre></td></tr></table></figure></li></ul><h4 id="非捕获分组"><a href="#非捕获分组" class="headerlink" title="非捕获分组"></a>非捕获分组</h4><p><strong>分组之后不再需要本组数据且不占组号</strong><br><img src="/2024/12/09/java/image%20copy%206.png" alt="alt text"></p><h2 id="时间相关类"><a href="#时间相关类" class="headerlink" title="时间相关类"></a>时间相关类</h2><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>创建一个对象表示当前时间(无参构造)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date d1= <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(d1);</span><br></pre></td></tr></table></figure><p>创建一个对象表示指定时间(有参构造)参数是long类型的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date d2= <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">0L</span>);</span><br><span class="line">System.out.println(d2);</span><br></pre></td></tr></table></figure><p>setTime修改时间(在起始时间上加)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d2.setTime(<span class="number">1000L</span>);<span class="comment">//毫秒值</span></span><br><span class="line">System.out.println(d2);</span><br></pre></td></tr></table></figure><p>获取当前时间的毫秒值(相对于起始时间)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> d2.getTime();</span><br><span class="line">System.out.println(time);<span class="comment">//1000</span></span><br></pre></td></tr></table></figure><h3 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h3><ul><li><code>public String format(Date date)</code>：<font color="red">将Date对象格式化为字符串。</font><br>无参构造<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf1= <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>();</span><br><span class="line"><span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">0L</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> sdf1.format(d1);</span><br><span class="line">System.out.println(str1);<span class="comment">//默认格式：1970/1/1 08:00</span></span><br></pre></td></tr></table></figure>有参构造<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss EE&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> sdf2.format(d1);</span><br><span class="line">System.out.println(str2);<span class="comment">//1970年01月01日 08:00:00 周四</span></span><br></pre></td></tr></table></figure></li><li><code>public Date parse(String source)</code>：<font color="red">将字符串解析为Date对象。</font><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;2000-11-11&quot;</span>;</span><br><span class="line">Date d1=sdf.parse(str);</span><br><span class="line">String  s1=sdf1.format(d1);</span><br><span class="line">System.out.println(s1);<span class="comment">//2000年11月11日</span></span><br><span class="line">System.out.println(d1.getTime());</span><br></pre></td></tr></table></figure></li></ul><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><p>抽象类，所以不能new</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static Calendar getInstance()</td><td>获取一个它的子类GregorianCalendar对象。  把当前时间的纪元，年月日等放入一个数组中</td></tr><tr><td>public int get(int field)</td><td>获取某个字段的值。field参数表示获取哪个字段的值，<br>可以使用Calender中定义的常量来表示：<br>Calendar.YEAR : 年<br>Calendar.MONTH ：月(下标0-11)<br>Calendar.DAY_OF_MONTH：月中的日期<br>Calendar.HOUR：小时<br>Calendar.MINUTE：分钟<br>Calendar.SECOND：秒<br>Calendar.DAY_OF_WEEK：星期(下标0表示周日)</td></tr><tr><td>public void set(int field,int value)</td><td>设置某个字段的值</td></tr><tr><td>public void add(int field,int amount)</td><td>为某个字段增加&#x2F;减少指定的值</td></tr></tbody></table><h3 id="JDK8新增时间相关类"><a href="#JDK8新增时间相关类" class="headerlink" title="JDK8新增时间相关类"></a>JDK8新增时间相关类</h3><table><thead><tr><th>JDK8时间类类名</th><th>作用</th></tr></thead><tbody><tr><td>ZoneId</td><td>时区</td></tr><tr><td>Instant</td><td>时间戳</td></tr><tr><td>ZoneDateTime</td><td>带时区的时间</td></tr><tr><td>DateTimeFormatter</td><td>用于时间的格式化和解析</td></tr><tr><td>LocalDate</td><td>年、月、日</td></tr><tr><td>LocalTime</td><td>时、分、秒</td></tr><tr><td>LocalDateTime</td><td>年、月、日、时、分、秒</td></tr><tr><td>Duration</td><td>时间间隔（秒，纳，秒）</td></tr><tr><td>Period</td><td>时间间隔（年，月，日）</td></tr><tr><td>ChronoUnit</td><td>时间间隔（所有单位）</td></tr></tbody></table><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p><strong>基本数据类型对应的对象</strong><br>JDK5以后对包装类新增了什么特性？<br>自动装箱（把基本数据类型自动变为其对应的包装类），自动拆箱</p><table><thead><tr><th>基本类型</th><th>对应的包装类（位于java.lang包中）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td><strong>Character</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public Integer(int   value)</td><td>根据 int 值创建 Integer 对象(过时)</td></tr><tr><td>public Integer(String s)</td><td>根据 String 值创建 Integer 对象(过时)</td></tr><tr><td>public static Integer valueOf(int i)</td><td>返回表示指定的 int 值的 Integer   实例</td></tr><tr><td>public static Integer valueOf(String s)</td><td>返回保存指定String值的 Integer 对象</td></tr><tr><td>static string tobinarystring(int i)</td><td>得到二进制</td></tr><tr><td>static string tooctalstring(int i)</td><td>得到八进制</td></tr><tr><td>static string toHexstring(int i)</td><td>得到十六进制</td></tr><tr><td>static int parseInt(string s)</td><td>将字符串类型的整数转成int类型的整数</td></tr></tbody></table><p>valueOf传的数字在[-128,127]范围中时，不会再重新new ，而是将已经准备好的数据从数组中取出来<br><img src="/2024/12/09/java/image%20copy%207.png" alt="alt text"><br>八种包装类中，除了character其他都有parseXXX的方法进行类型转换</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p><img src="/2024/12/09/java/image%20copy%208.png" alt="alt text"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ES6</title>
      <link href="/2024/12/08/ES6/"/>
      <url>/2024/12/08/ES6/</url>
      
        <content type="html"><![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h2><p><code>throw new Error(&#39;程序出错啦！&#39;)</code><br>程序会被中断，且抛出错误信息</p><h2 id="try…catch…finally"><a href="#try…catch…finally" class="headerlink" title="try…catch…finally"></a>try…catch…finally</h2><p>用于捕获错误信息，将可能会出错的代码放到try中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">&#125;catch(err)&#123;</span><br><span class="line">  console.log(err.message)</span><br><span class="line">  return ;</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">  alert(&#x27;不管try中的代码有没有出错我都会被执行&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与throw 不同的是，catch捕获到错误后并不会中断程序，所以我们可以手动加一个return；catch中的参数，有一个属性message，可以提供错误信息。</p><h1 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h1><p>作用域分为全局作用域(.js文件或在<code>&lt;script&gt;</code>标签中)，局部作用域分为函数作用域或块级作用域<br>作用域链：** 本质上是底层的 <em>变量查找机制</em> **,在函数被执行时，会优先查找当前作用域中查找变量，如果当前作用域查找不到，则会依次逐级查找父级作用域直到全局作用域</p><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>什么是垃圾回收机制？<br>JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收<br>什么是内存泄漏？不再用到的内存，没有及时释放，就叫做内存泄漏<br>内存的生命周期是什么样的？</p><ol><li>存分配、内存使用、内存回收</li><li>全局变量一般不会回收； 一般情况下局部变量的值, 不用了, 会被自动<br>回收掉<br>堆栈空间分配区别：</li><li>栈（操作系统）: 由操作系统自动分配释放函数的参数值、局部变量等，基本数据类型放到栈里面。</li><li>堆（操作系统）: 一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型放到堆里面。<br>两种常见的浏览器垃圾回收算法: 引用计数法 和 标记清除法</li></ol><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包&#x3D;内层函数+外层函数的变量<br>闭包的作用？</p><ol><li>封闭数据，实现数据私有，外部也可以访问函数内部的变量</li><li>闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来<br>闭包可能引起的问题？<br>内存泄漏</li></ol><h1 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h1><p>用哪个关键字声明变量会有变量提升？ var<br>变量提升是什么流程？</p><ol><li>先把var 变量提升到当前作用域于最前面</li><li>只提升变量声明， 不提升变量赋值</li><li>然后依次执行代码</li></ol><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h2><p>函数在声明之前即可被调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f()</span><br><span class="line">function f()&#123;</span><br><span class="line">  console.log(123)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不存在变量提升的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bar()</span><br><span class="line">var bar = function ()&#123;</span><br><span class="line">  console.log(123)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><ol><li><p>动态参数：arguments 是一个伪数组（不能使用数组的方法，只存在于函数中）<br>arguments 的作用是动态获取函数的实参（在不确定传过来的参数究竟有几个时，就不再写形参，直接使用arguments）可以通过for循环依次得到传递过来的实参</p></li><li><p>剩余参数<br>剩余参数主要的使用场景是？ 用于获取多余的实参<br>剩余参数和动态参数区别是什么？动态参数是伪数组；剩余参数是真数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function f(a,b,...other)&#123;</span><br><span class="line">  console.log(other)//注意不用写...了</span><br><span class="line">&#125;</span><br><span class="line">f(a,b,[c,d])</span><br></pre></td></tr></table></figure><p>打印结果就是c,d</p></li></ol><h3 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h3><p>使用场景：</p><ol><li>求数组最大值(因为数组没有直接求最大值的方法)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr=[1,5,3,8,2]</span><br><span class="line">console.log(Math.max(...arr))</span><br></pre></td></tr></table></figure></li><li>合并数组 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a1=[1,2,3]</span><br><span class="line">const a2=[4,5,6]</span><br><span class="line">const a3=[...a1,...a2]</span><br><span class="line">console.log(a3)//[1,2,3,4,5,6]</span><br></pre></td></tr></table></figure></li></ol><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p><strong>箭头函数属于表达式函数，所以不存在函数提升</strong><br><strong>箭头函数没有arguments，但是有剩余参数…arr</strong><br><strong>箭头函数不会创建自己的this,它只会从自己的作用域链的上一层沿用this</strong></p><h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>使用场景</p><ol><li>交换两个变量<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a=1</span><br><span class="line">let b=2;//注意这里一定要加;</span><br><span class="line">[b,a]=[a,b]//这里相当于右边是一个数组，进行解构赋值</span><br><span class="line">console.log(a)//2</span><br><span class="line">console.log(b)//1</span><br></pre></td></tr></table></figure></li><li>· <code>const [a,b]=[&#39;苹果&#39;]</code> b&#x3D;undefined<br>· <code>const [a,...arr]=[1,2,3,4]</code>  <code>arr=[2,3,4]</code><br>· 防止有undefined 可以设置默认值<br><code>const [a=&#39;手机&#39;,b=&#39;华为&#39;] = [&#39;小米&#39;]</code><br><code>console.log(a)//小米</code><br><code>console.log(b)//华为</code><br>· 按需导入，忽略某些值<br><code>const [a,,c] = [1,2,3]</code><br><code>console.log(a)//1</code><br><code>console.log(c)//3</code></li></ol><h2 id="js中必须加分号的情况"><a href="#js中必须加分号的情况" class="headerlink" title="js中必须加分号的情况"></a>js中必须加分号的情况</h2><ol><li>立即执行函数<code>(function f()&#123;&#125;)()</code></li><li>数组解构</li></ol><h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><ol><li>赋值运算符 &#x3D; 左侧的 {} 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量</li><li>对象属性的值将被赋值给与属性名相同的变量</li><li>注意解构的变量名不要和外面的变量名冲突否则报错</li><li>对象中找不到与变量名一致的属性时变量值为 undefined<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const pig = &#123;</span><br><span class="line">  name:&#x27;abc&#x27;,</span><br><span class="line">  family:&#123;</span><br><span class="line">    a:&#x27;12&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const &#123; name,family:&#123;a&#125; &#125; = pig</span><br></pre></td></tr></table></figure></li></ol><h1 id="创建对象的三种方式"><a href="#创建对象的三种方式" class="headerlink" title="创建对象的三种方式"></a>创建对象的三种方式</h1><ol><li>利用对象字面量创建对象<code>const o=&#123;name:&#39;wyh&#39;&#125;</code></li><li>利用new Object 创建对象 <code>const o=new Object(&#123;name:&#39;wyh&#39;&#125;)</code></li><li>利用构造函数创建对象<br>构造函数的两个约定：1.它们的命名以大写字母开头。2.它们只能由 “new” 操作符来执行。<br>说明：</li><li>使用 new 关键字调用函数的行为被称为实例化</li><li>实例化构造函数时没有参数时可以省略 ()</li><li>构造函数内部无需写return，返回值即为新创建的对象</li><li>构造函数内部的 return 返回的值无效，所以不要写return</li><li>new Object（） new Date（） 也是实例化构造函数</li></ol><p>什么是实例成员？实例对象的属性和方法即为实例成员<br>什么是静态成员？构造函数的属性和方法被称为静态成员</p><h1 id="内置构造函数"><a href="#内置构造函数" class="headerlink" title="内置构造函数"></a>内置构造函数</h1><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>常用的静态方法（只有构造函数Object可以调用）</p><ol><li>Object.keys()  获取所有属性名 Object.values(o)获取所有属性值</li><li>Object.assign() 拷贝，添加属性<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const  o =&#123; uname:&#x27;pink&#x27;,age: 18&#125;</span><br><span class="line">console.log(Object.keys(o))//返回数组[&#x27;uname&#x27;,&#x27;age&#x27;]</span><br><span class="line">console.log(Object.values(o))//返回数组[&#x27;pink&#x27;,18]</span><br><span class="line"></span><br><span class="line">//拷贝</span><br><span class="line">const obj=&#123;&#125;</span><br><span class="line">Object.assign(obj,o)</span><br><span class="line">console.log(obj)//&#123; uname:&#x27;pink&#x27;,age: 18&#125;</span><br><span class="line">Object.assign(o,&#123;gender:&#x27;女&#x27;&#125;)</span><br><span class="line">console.log(obj)//&#123; uname:&#x27;pink&#x27;,age: 18,gender:&#x27;女&#x27;&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h2><img src="/2024/12/08/ES6/image.png" width="200px" height="200px"><img src="/2024/12/08/ES6/image1.png" width="200px" height="200px"><ol><li>forEach()遍历数组  <strong>不会返回新数组</strong><br>数组.forEach(function(currentValue，index){}) </li><li>filter()过滤数组 <strong>返回筛选后的新数组</strong><br>被遍历数组.filter(function(currentValue,index){ return 筛选条件}) </li><li>map 迭代数组 <strong>返回处理之后的新数组</strong></li><li>reduce累计器 <strong>返回累计处理结果，常用于求和</strong><br><code>arr.reduce(function(上一次值，当前值)&#123;&#125;,初始值)</code><br><code>arr.reduce((上一次值，当前值)=&gt;&#123;&#125;,初始值)</code><br>如果是<strong>对象的属性</strong>进行累加的话，第二个参数不能省略<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const total = arr.reduce((prev,current)=&gt;&#123;</span><br><span class="line">  return prev+a.num</span><br><span class="line">&#125;,0)</span><br></pre></td></tr></table></figure></li><li>find() 方法返回数组中满足提供的测试函数的<strong>第一个元素的值</strong>。否则返回 undefined<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const array1 = [</span><br><span class="line">  &#123;</span><br><span class="line">    name:&#x27;小米&#x27;,</span><br><span class="line">    price:1999</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name:&#x27;华为&#x27;,</span><br><span class="line">    price:2999</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line">const found = array1.find(element =&gt; element.name===&#x27;小米&#x27;);//返回的是小米这个对象</span><br></pre></td></tr></table></figure></li><li>every() 方法测试一个数组内的所有元素是否都能通过指定函数的测试。它返回一个布尔值。</li><li>数组常见方法- 伪数组转换为真数组Array.from()<br>  arguments,querySelectorAll获得的都是伪数组</li><li>join<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const elements = [&#x27;Fire&#x27;, &#x27;Air&#x27;, &#x27;Water&#x27;];</span><br><span class="line">console.log(elements.join());</span><br><span class="line">// Expected output: &quot;Fire,Air,Water&quot;</span><br><span class="line">console.log(elements.join(&#x27;&#x27;));</span><br><span class="line">// Expected output: &quot;FireAirWater&quot;</span><br></pre></td></tr></table></figure></li></ol><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p><img src="/2024/12/08/ES6/image2.png"></p><ol><li>split<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const str = &#x27;The quick brown fox jumps over the lazy dog.&#x27;;</span><br><span class="line">const words = str.split(&#x27; &#x27;);</span><br><span class="line">console.log(words[3]);</span><br><span class="line">// Expected output: &quot;fox&quot;</span><br><span class="line">const chars = str.split(&#x27;&#x27;);</span><br><span class="line">console.log(chars[8]);</span><br><span class="line">// Expected output: &quot;k&quot;</span><br><span class="line">const strCopy = str.split();</span><br><span class="line">console.log(strCopy);</span><br><span class="line">// Expected output: Array [&quot;The quick brown fox jumps over the lazy dog.&quot;]</span><br></pre></td></tr></table></figure></li><li>substring()方法返回该字符串从起始索引到结束索引（不包括）的部分,如果未提供结束索引，则返回到字符串末尾的部分。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const str = &#x27;Mozilla&#x27;;</span><br><span class="line">console.log(str.substring(1, 3));</span><br><span class="line">// Expected output: &quot;oz&quot;</span><br><span class="line">console.log(str.substring(2));</span><br><span class="line">// Expected output: &quot;zilla&quot;</span><br></pre></td></tr></table></figure></li><li>startsWith() 方法用来判断当前字符串是否以另外一个给定的子字符串开头，并根据判断结果返回 true 或 false。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const str1 = &#x27;SatSatturday night plans&#x27;;</span><br><span class="line">console.log(str1.startsWith(&#x27;Sat&#x27;));</span><br><span class="line">// Expected output: true</span><br><span class="line">console.log(str1.startsWith(&#x27;Sat&#x27;, 3));</span><br><span class="line">// Expected output: true</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>String 值的 includes() 方法执行区分大小写的搜索，以确定是否可以在一个字符串中找到另一个字符串，并根据情况返回 true 或 false。</li></ol><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function financial(x) &#123;</span><br><span class="line">  return Number.parseFloat(x).toFixed(2);</span><br><span class="line">&#125;</span><br><span class="line">console.log(financial(123.456));</span><br><span class="line">// Expected output: &quot;123.46&quot;</span><br><span class="line">console.log(financial(0.004));</span><br><span class="line">// Expected output: &quot;0.00&quot;</span><br><span class="line">console.log(financial(&#x27;1.23e+5&#x27;));</span><br><span class="line">// Expected output: &quot;123000.00&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库常用命令</title>
      <link href="/2024/12/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/12/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><code>select name,age,score from student where age is not null</code><br>模糊查询:like<br>百分号（%）：表示任意长度的任意字符序列。<br>下划线（_）：表示任意单个字符。</p><p><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;</code><br>将root用户的认证方式改为mysql_native_password，并设置密码为123456,’localhost’表示可以从本地连接到数据库</p><h1 id="DDl"><a href="#DDl" class="headerlink" title="DDl"></a>DDl</h1><ul><li>添加字段 <code>ALTER TABLE 表名 ADD 类型（长度） [COMMENT] [约束]</code></li><li>修改数据类型<code>ALTER TABLE 表名 MODIFY 字段名 新数据类型</code></li><li>修改字段名和字段类型<code>ALTER TABLE 表名 CHANGE 新字段名 类型 [COMMENT] [约束]</code></li><li>删除字段<code>ALTER TABLE 表名 DROP 字段名</code></li><li>删除表 <code>DROP TABLE [IF EXISTS] 表名</code></li><li>删除指定表，并重新创建该表<code>TRUNCATE TABLE 表名</code></li><li>修改表名 <code>ALTER TABLE 表名 RENAME TO 新表名</code></li></ul><h1 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h1><ul><li>给指定字段添加数据 <code>INSERT INTO 表名(字段名1...) VALUES (值1...)</code></li><li>给全部字段添加数据<code>INSERT INTO 表名 VALUES (值1...)</code></li><li>删除数据<code>DELETE FROM 表名 [WHERE]</code></li></ul><h1 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h1><ul><li><code>SELECT FROM 表名 WHERE .. GROUP BY .. HAVING .. ORDER BY.. LIMIT..</code></li><li><code>DISTINCT</code><br><img src="/2024/12/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image.png"><br>HAVING是分组之后对结果进行过滤<br>NULL不参与聚合运算<br>执行顺序：<code>WHERE &gt; 聚合函数 &gt; HAVING</code></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>将项目部署到服务器</title>
      <link href="/2024/11/27/%E5%B0%86%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2024/11/27/%E5%B0%86%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ul><li><p>npm run build 将项目打包</p></li><li><p>利用electerm 连接到远程服务器</p></li><li><p>关于nginx的配置<br>先安装:在ssh命令行中输入<code>yum install nginx</code><br>进入nginx<code>cd nginx</code><br>进入nginx配置文件 <code>vim nginx.conf</code><br>修改用户权限:<code>user root;</code>否则会出现404<br>修改相关配置，下文有提及<br>esc + <code>:wq</code>保存退出<br>重启nginx服务：<code>systemctl restart nginx.service</code></p><p><code> nginx -s reload</code>重新加载配置文件<br><code>systemctl status nginx.service</code>查询状态<br><code>netstat -nap | grep 80</code>查看80端口被占用情况</p></li><li><p>一个服务器部署多个项目<br> 在nginx配置文件 <code>vim nginx.conf</code>中，有以下一行代码<br> <img src="/2024/11/27/%E5%B0%86%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/image%20copy%206.png" alt="alt text"><br> 说明在&#x2F;conf.d文件夹下，凡是以.conf结尾的文件都会被加载到配置文件中，因此，我们在&#x2F;conf.d文件夹下<code>touch filename</code> ,在该文件中写入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       8080;</span><br><span class="line">  server_name  47.98.123.91;    #此处使用测试域名。实际配置中使用您的服务器域名。</span><br><span class="line"></span><br><span class="line">  #charset koi8-r;</span><br><span class="line">  access_log  /var/log/nginx/b.access.log  main;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">      root   /root/syt/dist;    #测试站点路径。即您的项目代码路径。</span><br><span class="line">      index  index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">  error_page   500 502 503 504  /50x.html;</span><br><span class="line">  location = /50x.html &#123;</span><br><span class="line">      root   /usr/share/nginx/html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<font color="red">要在服务器的配置安全组中开放相应的端口</font><br><a href="https://help.aliyun.com/zh/dws/user-guide/register-a-domain-name-on-alibaba-cloud?spm=a2c4g.11186623.0.0.67fa19b5YtAxaP">https://help.aliyun.com/zh/dws/user-guide/register-a-domain-name-on-alibaba-cloud?spm=a2c4g.11186623.0.0.67fa19b5YtAxaP</a></p></li></ul><h1 id="了解到的相关知识"><a href="#了解到的相关知识" class="headerlink" title="了解到的相关知识"></a>了解到的相关知识</h1><ol><li><p>本机打开windos+R 打开<code>mstsc /admin</code>,点击确定，出现</p><img src="/2024/11/27/%E5%B0%86%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/image copy.png" height="150px" width="200px">将自己买的服务器的公网ip填进去，点击连接。就可以进入购买的服务器的windows操作系统。注意这里的用户名是Administer,试了root和administer都不对使用 mstsc /admin 连接到远程服务器属于远程桌面连接的高级用法，具体来说，是通过Windows自带的远程桌面协议(RDP)来实现的。这种方法允许用户通过图形用户界面（GUI）远程访问和控制远程服务器.</li><li><p>在该windows中安装nginx。<br>关于nginx的介绍：<a href="https://blog.csdn.net/b9x__/article/details/80400697">https://blog.csdn.net/b9x__/article/details/80400697</a><br><a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a><br><img src="/2024/11/27/%E5%B0%86%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/image copy 2.png" height="150px" width="300px">下载后解压即可。<br>具体操作步骤：<br><a href="https://blog.csdn.net/qq_31762741/article/details/121796712">https://blog.csdn.net/qq_31762741/article/details/121796712</a><br>打开文件夹，cmd 中输入<code>start nginx</code>以启动Nginx<br>如果窗口闪了一下，在浏览器中打开<a href="http://localhost:80,则表示安装成功。">http://localhost:80,则表示安装成功。</a></p></li><li><p>修改nginx配置<br>只需要修改以下两项 </p><img src="/2024/11/27/%E5%B0%86%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/image.png" height="150px" width="200px">listen   22;表示你的端口号server_name 你买的服务器的Iproot html;这个指令指定了请求的根目录。在这个例子中，root html; 意味着当Nginx接收到请求时，它会在服务器的文件系统中查找一个名为 html 的目录，并将这个目录作为请求的根目录。需要注意的是，这里的 html 目录是相对于Nginx配置文件中定义的根路径（例如，通过 prefix 指令或编译时指定的默认路径）或者是绝对路径（如果 html 前有 /，表示从根文件系统开始）。index index.html index.htm;这个指令指定了当请求是一个目录而非文件时，Nginx 应该尝试返回哪个文件作为默认页面。在这个例子中，index index.html index.htm;指示Nginx，如果请求的是一个目录则Nginx会尝试依次查找该目录下的 index.htm 文件。综上所述，这段配置的目的是告诉Nginx，当接收到对根URL（/）的请求时，应该在服务器的 html 目录下查找资源，如果请求的是一个目录，则尝试返回该目录下的 index.html 文件。</li><li><p>修改完在此路径下的cmd 中输入<code>nginx -s reload</code></p></li><li><p>配置安全组<br>在你的服务器实例上配置一个以你的端口号为端口范围的入方向的配置规则。</p></li><li><p>在防火墙中设置一个入站规则<br><img src="/2024/11/27/%E5%B0%86%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/image copy 3.png" height="150px" width="200px">只需要改如图的配置即可。<br>最后，在任意ip输入你的服务器公网ip+端口号就可以访问！</p></li></ol><h2 id="在Windows电脑上启动并配置SSH服务"><a href="#在Windows电脑上启动并配置SSH服务" class="headerlink" title="在Windows电脑上启动并配置SSH服务"></a>在Windows电脑上启动并配置SSH服务</h2><p>SSH全称secure shell，安全外壳协议（安全的shell），是一个计算机网络协议（默认端口号为22）。通过ssh协议可以在客户端安全（提供身份认证、信息加密）的远程连接LInux服务器或其他设备。<br>SSH远程连接之后，就可以像操作本地的机器一样操作远程机器。当需要操控的机器不在本地时就可以使用ssh协议远程连接操控。<br>原文链接：<a href="https://blog.csdn.net/m0_51720581/article/details/131796669">https://blog.csdn.net/m0_51720581/article/details/131796669</a><br>1.按下Win+R键输入services.msc,在服务列表中查找“OpenSSH SSH Server”服务.如果没找到就说明没有安装。<br>安装SSH服务：<br>搜索可选功能-&gt;添加可选功能-&gt;找到OpenSSH服务器-&gt;添加。<br>安装后，重复1的操作，点击启动服务，并且右击-&gt;属性-&gt;启动类型-&gt;’自动’-&gt;确定。<br>2.设置防火墙规则以允许SSH连接。在“控制面板”中的“Windows Defender 防火墙”设置中，允许端口22（SSH默认端口）的入站连接。<br>远程桌面协议—RDP</p><h2 id="利用Workbench远程连接-用RDP连接windows实例-SSH连接linux实例"><a href="#利用Workbench远程连接-用RDP连接windows实例-SSH连接linux实例" class="headerlink" title="利用Workbench远程连接(用RDP连接windows实例,SSH连接linux实例)"></a>利用Workbench远程连接(用RDP连接windows实例,SSH连接linux实例)</h2> <img src="/2024/11/27/%E5%B0%86%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/image copy 4.png" height="150px" width="300px"><img src="/2024/11/27/%E5%B0%86%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/image4.png" height="150px" width="300px">就可以进入远程操作系统界面了<h2 id="用vscode-sftp"><a href="#用vscode-sftp" class="headerlink" title="用vscode+sftp"></a>用vscode+sftp</h2><p><a href="https://blog.csdn.net/huachizi/article/details/131984148">https://blog.csdn.net/huachizi/article/details/131984148</a></p><p>sftp是对于文件的协议，ssh是对于命令行的协议，http是对于请求的协议</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>查漏补缺</title>
      <link href="/2024/11/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2024/11/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><p>1.页面导入样式时，使用link和@import有什么区别?<br>答：</p><table><thead><tr><th align="center"></th><th align="center">link</th><th align="center">@import</th></tr></thead><tbody><tr><td align="center">语法</td><td align="center">html标签</td><td align="center">css语法</td></tr><tr><td align="center">在js中</td><td align="center">可以被动态修改</td><td align="center">不可以在js中被修改</td></tr><tr><td align="center">支持资源类型</td><td align="center">支持多种资源，如 CSS、图标、字体等</td><td align="center">只支持 CSS 文件</td></tr><tr><td align="center">加载方式</td><td align="center">浏览器并行加载HTML和CSS</td><td align="center">先加载 HTML后加载@import的CSS</td></tr></tbody></table><p>2.区分出行内元素、块级元素、空元素并在后面简要标注下作用。<br>行内元素：<code>&lt;span&gt;</code>,<code>&lt;img&gt;</code><br><code>&lt;a&gt;</code>：超链接<br><code>&lt;strong&gt;</code>：强调文本（通常显示为加粗）<br><code>&lt;em&gt;</code>：强调文本（通常显示为斜体）<br><code>&lt;b&gt;</code>：加粗文本<br><code>&lt;i&gt;</code>：斜体文本<br><code>&lt;u&gt;</code>：下划线文本<br><code>&lt;code&gt;</code>：显示计算机代码的文本<br><code>&lt;abbr&gt;</code>：缩写<br><code>&lt;time&gt;</code>：日期和时间<br><code>&lt;br&gt;</code>：换行符<br><code>&lt;small&gt;</code>：显示小号文本<br>块级元素：<code>&lt;p&gt;</code>,<code>&lt;div&gt;</code>,<br><code>&lt;h1&gt;</code><br><code>&lt;ul&gt;</code>：无序列至表<br><code>&lt;ol&gt;</code>：有序列表<br><code>&lt;li&gt;</code>：列表项<br><code>&lt;section&gt;</code>：文档的一个区段<br><code>&lt;article&gt;</code>：独立的内容块，常用于博客文章等<br><code>&lt;header&gt;</code>：文档或区块的头部<br><code>&lt;footer&gt;</code>：文档或区块的尾部<br><code>&lt;nav&gt;</code>：导航链接的区域<br><code>&lt;form&gt;</code>：表单<br><code>&lt;table&gt;</code>：表格<br><code>&lt;blockquote&gt;</code>：引用块<br><code>&lt;figure&gt;</code>：图像、插图或其他媒体的内容块<br>空元素：空元素（也称自闭合元素）是不需要闭合标签的元素，它们通常用于结构或嵌入内容，不包含子元素或文本内容。<br><code>&lt;img&gt;</code>, <code>&lt;br&gt;</code>, <code>&lt;input&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;meta&gt;</code><br>3.css3引入了哪些新的特性？<br>答：</p><ol><li>选择器（Selectors）<br><strong>属性选择器</strong>：选择具有特定属性或属性值的元素。<br> 选择所有 class 属性值包含 “example” 的元素 *&#x2F;<br><code>[class*=&quot;example&quot;] &#123; color: red; &#125;</code><br><strong>伪类选择器</strong>：<br>:nth-child(): 匹配父元素中的第 N 个子元素。<br>li:nth-child(odd) { background-color: #f0f0f0; } &#x2F;* 匹配奇数项 *&#x2F;<br>:nth-of-type(): 匹配特定类型的第 N 个元素。<br>:not(): 排除特定元素。<br>:first-child, :last-child: 选择第一个或最后一个子元素。<br><strong>伪元素选择器</strong>：<br>::before, ::after: 在元素内容前或后插入内容。<br>::first-letter, ::first-line: 选择文本的首字母或首行。</li><li>盒模型（Box Model）增强<br>box-sizing: border-box; &#x2F;* 包括边框和内边距在内的总宽度和高度 *&#x2F;</li><li>边框（Borders）<br>圆角边框（border-radius）：可以为元素的四个角添加圆角效果。<br>多重边框（border-image）：允许设置边框使用图片。</li><li>背景（Backgrounds）<br>渐变背景（background-image: linear-gradient() 和 radial-gradient()）：<br><code>background-image: linear-gradient(to right, red, yellow);</code><br>径向渐变：从中心向外渐变。<br><code>background-image: radial-gradient(circle, red, yellow);</code><br>背景附着（background-attachment）：控制背景图像是否随着页面滚动而滚动。<br>background-attachment: fixed; &#x2F;* 背景固定，滚动时不会滚动 *&#x2F;</li><li>文本效果<br>文本阴影（text-shadow）<br>text-shadow: 2px 2px 4px #000000;<br>文字溢出（text-overflow）：处理文本超出元素边界时的显示方式。<br>text-overflow: ellipsis; &#x2F;* 显示省略号 *&#x2F;</li><li>过渡（Transitions）<br>transition: all 0.3s ease;</li><li>动画（Animations）<br>CSS3 动画允许通过 @keyframes 创建复杂的动画效果：<br>@keyframes：定义关键帧动画。<br>css<br>复制代码<br>@keyframes move {<br>  from { left: 0; }<br>  to { left: 100px; }<br>}<br>div {<br>  position: relative;<br>  animation: move 2s infinite;<br>}</li><li>弹性盒布局（Flexbox）<br>.container {<br>  justify-content: center; &#x2F;* 水平居中 <em>&#x2F;<br>  align-items: center; &#x2F;</em> 垂直居中 *&#x2F;<br>}</li><li>多列布局（Multi-column Layout）<br>CSS3 引入了对多列布局的支持，使得文本可以像报纸一样分栏显示。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  column-count: 3; /* 分成3列 */</span><br><span class="line">  column-gap: 20px; /* 列之间的间隙 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>阴影（Box Shadows）<br>CSS3 允许为元素添加阴影，使得页面视觉效果更丰富。<br>盒子阴影（box-shadow）：<br><code>box-shadow: 10px 10px 5px #888888;</code></li><li>媒体查询（Media Queries）<br>CSS3 引入了媒体查询，使得根据不同的设备或屏幕尺寸加载不同的样式成为可能。它是响应式设计的核心。<br>基本语法：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@media (max-width: 600px) &#123;</span><br><span class="line">  body &#123;</span><br><span class="line">    background-color: lightblue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>自定义属性（CSS Variables）<br>CSS3 引入了自定义属性，也叫 CSS 变量，使得样式可以动态地改变并在不同地方复用。</li></ol><p>:root {<br>  –main-color: #ff6347;<br>}<br>div {<br>  background-color: var(–main-color);<br>}<br>13.  字体和文本<br>CSS3 还改进了字体相关的特性，特别是 Web 字体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &#x27;MyCustomFont&#x27;;</span><br><span class="line">  src: url(&#x27;myfont.woff2&#x27;) format(&#x27;woff2&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>font-feature-settings：开启或禁用特定的 OpenType 字体特性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue3组件通信方式</title>
      <link href="/2024/11/21/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
      <url>/2024/11/21/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="组件通信方式"><a href="#组件通信方式" class="headerlink" title="组件通信方式"></a>组件通信方式</h1><h2 id="pinia-仓库"><a href="#pinia-仓库" class="headerlink" title="pinia 仓库"></a>pinia 仓库</h2><h3 id="使用场景：组件间的通信"><a href="#使用场景：组件间的通信" class="headerlink" title="使用场景：组件间的通信"></a>使用场景：组件间的通信</h3><h3 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h3><ul><li>安装并引入npm install pinia，import { createPinia } from ‘pinia’</li><li>创建大仓库const pinia &#x3D; createPinia()并暴露，在main.ts中引入并使用app.use(pinia)</li><li>在store&#x2F;modules下可以定义小仓库，import { defineStore } from ‘pinia’,let useUserStore &#x3D; defineStore(‘User’,函数或箭头函数)<ul><li>选择式API：state（箭头函数的形式）、getter 和 action</li><li>组合式API：记得return</li></ul></li></ul><h2 id="WeChat-public-number"><a href="#WeChat-public-number" class="headerlink" title="WeChat public number"></a>WeChat public number</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于Pinia</title>
      <link href="/2024/11/10/%E5%85%B3%E4%BA%8EPinia/"/>
      <url>/2024/11/10/%E5%85%B3%E4%BA%8EPinia/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://pinia.vuejs.org/zh/getting-started.html">https://pinia.vuejs.org/zh/getting-started.html</a></p><h1 id="Store-是什么？"><a href="#Store-是什么？" class="headerlink" title="Store 是什么？"></a>Store 是什么？</h1><p>Store (如 Pinia) 是一个保存状态和业务逻辑的实体，它并不与你的组件树绑定。换句话说，它承载着全局状态。它有点像一个永远存在的组件，每个组件都可以读取和写入它。它有三个概念，state、getter 和 action，我们可以假设这些概念相当于组件中的 data、 computed 和 methods。</p><h1 id="应该在什么时候使用-Store"><a href="#应该在什么时候使用-Store" class="headerlink" title="应该在什么时候使用 Store?"></a>应该在什么时候使用 Store?</h1><p>一个 Store 应该包含可以在整个应用中访问的数据。这包括在许多地方使用的数据，例如显示在导航栏中的用户信息，以及需要通过页面保存的数据，例如一个非常复杂的多步骤表单。</p><p>另一方面，你应该避免在 Store 中引入那些原本可以在组件中保存的本地数据，例如，一个元素在页面中的可见性。</p><h1 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h1><p>首先<code>npm install pinia</code><br>然后在入口文件中引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createPinia &#125; from &#x27;pinia&#x27;</span><br><span class="line">const pinia = createPinia()</span><br><span class="line">const app = createApp(App)</span><br><span class="line">app.use(pinia)</span><br><span class="line">app.mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure><p>以硅谷甄选为例，我们把store放入src&#x2F;store中（大仓库），而store下的modules可以放许多小仓库<br>一个小仓库：在仓库中的<strong>this</strong>就指创建的仓库对象</p><h2 id="选择式API的写法"><a href="#选择式API的写法" class="headerlink" title="选择式API的写法"></a>选择式API的写法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//创建用户相关的小仓库</span><br><span class="line">import &#123; defineStore &#125; from &#x27;pinia&#x27;</span><br><span class="line">import &#123; reqLogin &#125; from &#x27;../../api/user&#x27;</span><br><span class="line">import type &#123; loginForm &#125; from &#x27;../../api/user/type&#x27;</span><br><span class="line">//定义用户小仓库</span><br><span class="line">let useUserStore = defineStore(&#x27;User&#x27;, &#123;</span><br><span class="line">  //小仓库，存储数据的地方</span><br><span class="line">  state() =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      data: 111,</span><br><span class="line">      arr:[1,2,3,4,5]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  //异步|逻辑的地方</span><br><span class="line">  actions: &#123;</span><br><span class="line">    update()&#123;</span><br><span class="line">      this.data++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;//对数据进行加工,也可以通过state.属性的形式访问数据</span><br><span class="line">    total(state)&#123;</span><br><span class="line">      let result = this.arr.reduce((prev,next)=&gt;&#123;</span><br><span class="line">        return prev + next</span><br><span class="line">      &#125;,0)</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">//对外暴露获取小仓库的方法</span><br><span class="line">export default useUserStore</span><br></pre></td></tr></table></figure><h2 id="组合式API的写法"><a href="#组合式API的写法" class="headerlink" title="组合式API的写法"></a>组合式API的写法</h2><p><strong>箭头函数务必要返回一个对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineStore &#125; from &#x27;pinia&#x27;</span><br><span class="line">//定义用户小仓库</span><br><span class="line">let useUserStore = defineStore(&#x27;User&#x27;, ()=&gt;&#123;</span><br><span class="line">  let arr=ref([&#123;id:1,title:&#x27;chifan&#x27;&#125;,&#123;id:2,title:&#x27;chifan&#x27;&#125;])</span><br><span class="line">  return &#123;</span><br><span class="line">    arr</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="在组件中获取数据的方法"><a href="#在组件中获取数据的方法" class="headerlink" title="在组件中获取数据的方法"></a>在组件中获取数据的方法</h1><h2 id="在组件中批量修改仓库中的数据"><a href="#在组件中批量修改仓库中的数据" class="headerlink" title="在组件中批量修改仓库中的数据:"></a>在组件中批量修改仓库中的数据:</h2><p>仓库名.$patch({<br>  属性名：新的属性值<br>})</p><h2 id="storeToRefs与ToRefs"><a href="#storeToRefs与ToRefs" class="headerlink" title="storeToRefs与ToRefs"></a>storeToRefs与ToRefs</h2><p>我们不想以仓库名.属性名的形式访问，想把仓库名省略掉，在解构赋值时，应该用到storeToRefs以保证它的响应式，storeToRefs只会将数据加上ref,而ToRefs还会将仓库中对应的方法也加上ref(没必要)，所以我们采用前者<code>const &#123;a,b,c&#125; = storeToRefs(仓库名)</code></p><h2 id="subscribe的使用"><a href="#subscribe的使用" class="headerlink" title="$subscribe的使用"></a>$subscribe的使用</h2><p>当仓库中的数据发生变化时，被调用<br>其中<br><code> localStorage.setItem(&quot;TOKEN&quot;, result.data.token)</code>setItem 是 localStorage 对象的一个方法，用于将数据保存到本地存储中。它接受两个参数：一个键（key）和一个值（value）。键和值都应该是字符串。如果值不是字符串，它会被自动转换成字符串。<br><code>let result = await reqLogin(data)</code>result接收的是reqLogin函数的返回值<br><code>reqLogin = (data: loginForm) =&gt; requests.post&lt;any, loginResponseData&gt;(API.LOGIN_URL, data)</code>,<code>loginResponseData</code>类型包括code: number,data:dataType其中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface dataType &#123;</span><br><span class="line">  token: string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以下面是result.data.token<br>async函数会返回一个promise表示状态，而该状态取决于async函数的返回值<br>Promise 对象：<br>Promise 是 JavaScript 中用于异步编程的一个对象，它代表了一个可能现在还不可用，但将来某个时刻会变得可用的值。<br>Promise 有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。<br>Promise.reject 方法：<br>Promise.reject 是 Promise 构造函数的一个静态方法，用于返回一个状态为 rejected 的新 Promise 实例。<br>它接受一个参数，这个参数通常是一个错误对象或错误信息的字符串，表示 Promise 被拒绝的原因。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>guigu2</title>
      <link href="/2024/11/10/guigu2/"/>
      <url>/2024/11/10/guigu2/</url>
      
        <content type="html"><![CDATA[<h2 id="login组件的静态页面"><a href="#login组件的静态页面" class="headerlink" title="login组件的静态页面"></a>login组件的静态页面</h2><h3 id="需要掌握的element插件的使用"><a href="#需要掌握的element插件的使用" class="headerlink" title="需要掌握的element插件的使用"></a>需要掌握的element插件的使用</h3><p><a href="https://element-plus.org/zh-CN/component/input.html">https://element-plus.org/zh-CN/component/input.html</a><br>如果是组件的话需要引入，并且要动态绑定，例如：<br><code>&lt;el-input type=&quot;password&quot; :show-password=true  :prefix-icon=&quot;Unlock&quot; v-model=&quot;loginForm.password&quot;&gt;&lt;/el-input&gt;</code></p><h2 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h2><h3 id="try-块"><a href="#try-块" class="headerlink" title="try 块"></a>try 块</h3><p>try 块包含了可能会产生错误的代码。当 try 块中的代码执行时，如果抛出了错误，并且这个错误没有被 try 块内部的任何代码捕获，那么程序的控制流就会跳转到与 try 块相关联的 catch 块（如果有的话）。</p><h3 id="catch-块"><a href="#catch-块" class="headerlink" title="catch 块"></a>catch 块</h3><p>catch 块紧跟在 try 块之后，并且只会在 try 块中的代码抛出一个错误时执行。catch 块通常包含用于处理错误的代码，比如记录错误信息、清理资源、向用户显示错误消息等。<br>在 catch 块中，你可以访问一个特殊的变量（通常命名为 error 或 e），它包含了错误的详细信息。这个变量是 try 块中抛出的错误对象的一个实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">  await useStore.userLogin(loginForm)</span><br><span class="line">  //编程式导航 </span><br><span class="line">  $router.push(&#x27;/&#x27;)</span><br><span class="line">  ElNotification(&#123;</span><br><span class="line">    type: &#x27;success&#x27;,</span><br><span class="line">    message:&#x27;登录成功&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">  IsSuccess.value=false</span><br><span class="line">&#125;catch(error)&#123;</span><br><span class="line">  //登陆失败</span><br><span class="line">  IsSuccess.value=false</span><br><span class="line">  ElNotification(&#123;</span><br><span class="line">    type: &#x27;error&#x27;,</span><br><span class="line">    message: &#x27;登录失败&#x27;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>useStore.userLogin(loginForm)</code>会返回正确或错误信息，如果返回的是正确的，那么就把try中的代码执行完；反之，就执行catch块中的；ElNotification是el组件库；<br>.then(result &#x3D;&gt; { … }) 方法在 Promise 成功解决时被调用，result 是 userLogin 函数解决时返回的值。<br>.catch(error &#x3D;&gt; { … }) 方法在 Promise 被拒绝时被调用，error 是拒绝的原因。<br>转化成.then的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const login = () =&gt; &#123;</span><br><span class="line">  // 开始加载，假设 IsSuccess 是一个响应式引用</span><br><span class="line">  IsSuccess.value = true;</span><br><span class="line">  // 调用仓库的登录请求，并处理 Promise</span><br><span class="line">  useStore.userLogin(loginForm)</span><br><span class="line">    .then(result =&gt; &#123;</span><br><span class="line">      // 请求成功后的操作</span><br><span class="line">      // 编程式导航到首页</span><br><span class="line">      $router.push(&#x27;/&#x27;);</span><br><span class="line">      // 显示登录成功的通知</span><br><span class="line">      ElNotification(&#123;</span><br><span class="line">        type: &#x27;success&#x27;,</span><br><span class="line">        message: &#x27;登录成功&#x27;</span><br><span class="line">      &#125;);</span><br><span class="line">      IsSuccess.value = false;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(error =&gt; &#123;</span><br><span class="line">      // 请求失败后的操作</span><br><span class="line">      IsSuccess.value = false;</span><br><span class="line">      // 显示登录失败的通知</span><br><span class="line">      ElNotification(&#123;</span><br><span class="line">        type: &#x27;error&#x27;,</span><br><span class="line">        message: &#x27;登录失败&#x27; </span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="菜单栏的封装"><a href="#菜单栏的封装" class="headerlink" title="菜单栏的封装"></a>菜单栏的封装</h2><p>2024-11-11;今天主要完成了这个部分。<br>大体思路是：菜单栏是一些路由的“集合”，我们期望可以通过每一个选项（路由）获得相应的组件。我们先对菜单组件进行封装，因为不同的身份登录，会展示不同的选项，考虑到复用性。在菜单组件中，我们又期望可以路由信息，从路由信息的角度命名每个选项，这样当我们选择时，右侧展示区域就可以轻易的展示出对应的信息。那么如何获得路由信息呢？1.路由信息已经对外暴露，我们只需要引入（pass）2.将路由信息导入我们的user仓库中，这样全局都可以查询路由信息，这时遇到了问题：关于export 和export default以及路由信息的类型定义问题(引入RouteRecordRaw)。然后，我们可以在父组件中引入仓库，再通过prop的方式传递给子组件。可是<strong>为什么不能直接在菜单组件中引入仓库呢？</strong>菜单组件拿到数据以后，可以将数据分为三类：1.没有二级路由的2.有一个二级路由的3.有两个及以上二级路由的。我们根据这三类，划分为两类，前两种直接将路由信息展示即可，后面一种需要折叠菜单，并且用到了<strong>递归思想</strong>，将二级路由再传递给当前组件，组件的递归需要再命名（在本组件中）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">  name: &#x27;Menu&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>然后呈现的应该是路由中meta属性中自定义的名字。这里就解释了上文<strong>为什么不能直接在菜单组件中引入仓库</strong>的问题，如果我们直接在子组件中引入的话，就无法实现递归，没有办法将当前的数据传递给自己。最后就是根据需求在meta中再定义一个hidden属性来就决定某个选项是否展示。<br>以下是一些总结：首先，菜单栏这部分主要用到el组件库的<code>&lt;el-scrollbar class=&quot;scrollbar&quot;&gt;</code>滑动，<code>&lt;el-menu background-color=&quot;#001529&quot; text-color=&quot;white&quot;&gt;</code>菜单，嵌套的元素是<code>&lt;el-menu-ite&gt;</code>,可以折叠的菜单<code>&lt;el-sub-menu&gt;</code>,组件库中用到的是这几项。一定要注意：<code>&lt;el-menu-ite&gt;</code>,<code>&lt;el-sub-menu&gt;</code>都在<code>&lt;el-menu&gt;</code>里面，否则会报错。<br>更为具体的用法为：<br>父组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-scrollbar class=&quot;scrollbar&quot;&gt;</span><br><span class="line">&lt;!-- 菜单组件 --&gt;</span><br><span class="line">  &lt;el-menu background-color=&quot;#001529&quot; text-color=&quot;white&quot;&gt;</span><br><span class="line">    &lt;Menu :menuList=&quot;userStore.menuRoutes&quot;&gt;&lt;/Menu&gt;</span><br><span class="line">  &lt;/el-menu&gt;</span><br><span class="line">&lt;/el-scrollbar&gt;  </span><br></pre></td></tr></table></figure><p>子组件：(这里只举了一个子组件的用法)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 没有子路由 --&gt;（外面有一个对父组件传递过来的数据的遍历）</span><br><span class="line">&lt;template v-if=&quot;!item.children&quot;&gt;</span><br><span class="line">  &lt;el-menu-item :index=&quot;item.path&quot; v-if=&quot;item.meta.hidden&quot;&gt;</span><br><span class="line">  &lt;template #title&gt;//插槽，可以自定义标题的内容</span><br><span class="line">    &lt;span&gt;biao&amp;nbsp;&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123;item.meta.title&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="在Vue-Router的路由视图中实现带有过渡效果的组件渲染"><a href="#在Vue-Router的路由视图中实现带有过渡效果的组件渲染" class="headerlink" title="在Vue Router的路由视图中实现带有过渡效果的组件渲染"></a>在Vue Router的路由视图中实现带有过渡效果的组件渲染</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view v-slot=&quot;&#123; Component &#125;&quot;&gt;</span><br><span class="line">  &lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt;</span><br><span class="line">    &lt;component :is=&quot;Component&quot; v-if=&quot;flag&quot;&gt;&lt;/component&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;component :is=&quot;Component&quot; v-if=&quot;flag&quot;&gt;&lt;/component&gt;</code>:<code>&lt;component&gt;</code>是Vue的一个动态组件，它的:is属性用于绑定一个组件，这个组件可以是已注册的组件，或者是一个组件的选项对象。在这里，:is&#x3D;”Component”意味着<code>&lt;component&gt;</code>将动态渲染由<code>&lt;router-view&gt;</code>插槽提供的Component.<br>v-slot&#x3D;”{ Component }”:<br>这里使用了Vue的插槽（slot）和作用域插槽（scoped slot）的概念。<code>&lt;router-view&gt;</code>的v-slot允许你访问到路由组件本身，而不是直接渲染它。这里的{ Component }是一个对象解构，它从<code>&lt;router-view&gt;</code>的作用域插槽中获取了一个名为Component的属性，这个属性代表了当前应该被渲染的路由组件。</p><h2 id="menu的collapse属性，面包屑，全屏模式"><a href="#menu的collapse属性，面包屑，全屏模式" class="headerlink" title="menu的collapse属性，面包屑，全屏模式"></a>menu的collapse属性，面包屑，全屏模式</h2><p><a href="https://element-plus.org/zh-CN/component/menu.html#menu-%E8%8F%9C%E5%8D%95">https://element-plus.org/zh-CN/component/menu.html#menu-%E8%8F%9C%E5%8D%95</a><br>在 Vue Router 中，$route.matched 是一个数组，它包含了当前路由匹配到的所有嵌套路径片段的路由记录。这些路由记录是 routes 配置数组中的对象副本（包括在 children 数组中的路由记录）。<br>具体来说，当你访问一个 URL 时，Vue Router 会根据配置的路由规则进行匹配，找到与当前 URL 最匹配的路由记录，并将其存储在 $route 对象中。同时，$route.matched 会包含从根路由开始到当前路由的所有匹配到的路由记录，这些记录按照匹配顺序排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const IsFullScreen=()=&gt;&#123;</span><br><span class="line">  let full = document.fullscreenElement</span><br><span class="line">  //如果不是全屏</span><br><span class="line">  if(full)&#123;</span><br><span class="line">    document.exitFullscreen()</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    document.documentElement.requestFullscreen()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>菜单折叠遇到的问题：图标的抖动，右边组件的抖动；解决办法：摒弃flex布局。<br>2024-11-13</p><h2 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h2><p>2024-11-13<br>登录成功后，服务器返回用户的唯一标识(Token)。然后在请求拦截器中通过请求头将Token发送到服务器端。页面挂载完毕后，向服务器发送请求获取用户信息，想要获取用户信息，就需要引入&#x2F;api&#x2F;user中的reqUserInfo的获取用户信息接口方法，由于用户信息会被多个组件用到，所以我们将获取到的信息存到仓库中，在仓库中如果请求成功了我们再存入数据，否则返回错误信息。这样其他任何组件都可以使用了。<br>遇到的困难就是用reqUserInfo接收所需要的用户信息时，数据类型不正确，导致无法正确引用。解决方案：把返回类型设置为any</p><h2 id="路由鉴权"><a href="#路由鉴权" class="headerlink" title="路由鉴权"></a>路由鉴权</h2><p>2024-11-14<br>在permission.ts文件中操作<br>当用户登陆成功后，切换路由时，要进行判断是否可以跳转路由。因此我们引入路由守卫（前置，后置）进行条件判断。（每次路由跳转前都会自动进行条件判断）<br>今天遇到的问题：用户信息正确但是登录失败，在用户没有登录时，TOKEN就已经存在<br>为什么，从主页退出登陆后再登录就可以，直接从login页面登录就不行<br>为什么程序一运行进入的是主页而不是登录页面？在哪规定的？答：在路由的定义里，我们把&#x2F;重定向到login 就会变成程序一运行就到登录页面，而&#x2F;重定向到Home就会直接到主页。<br>取消进度条右侧加载的小圈<code>Nprogress.configure(&#123; showSpinner: false &#125;);</code></p><p>由于token 会有过期的可能，（实例：淘宝登录，会隔一段时间让你重新登录账号），当每次切换路由时，我们利用路由守卫发送请求请求到服务端，获取用户信息。也就是只是改变了向服务器发请求获取用户信息的时机。以前是在页面挂载后，这种情况就忽视了token 过期的可能。<br>但是还有问题，如果手动修改了本地存储的值，那么切换路由时并不会返回到登陆页面，只有刷新时才会怎么解决？？？？？？？<br><code>[env.VITE_APP_BASE_API]</code>: 这种写法被称为计算属性名<br>VITE_APP_BASE_API&#x3D;myApiEndpoint在你的配置对象中，<code>[env.VITE_APP_BASE_API]</code>: 实际上会被解析为 “myApiEndpoint”这种写法的好处是，你可以通过修改环境变量来改变配置，而不需要直接修改代码。</p><h2 id="品牌管理模块–静态页面搭建和数据展示"><a href="#品牌管理模块–静态页面搭建和数据展示" class="headerlink" title="品牌管理模块–静态页面搭建和数据展示"></a>品牌管理模块–静态页面搭建和数据展示</h2><p>2024-11-15<br>首先今天遇到了一个关于路由方面问题，以前没有搞明白。就是如何在某个页面下的某一部分展示另一个二级路由组件。其实很简单：只需要在父组件中要被展示的地方放入<code>&lt;router-view&gt;</code>，这里就是展示你想要的东西（下面我们将这个组件称为展示组件）。接下来就是路由的配置！！！我们想让一个二级路由的组件展示在某个页面的某部分，需要将其以及路由的路径改为展示组件的路径，这样访问二级路由时，会首先访问展示组件的页面，然后检测到展示组件有<code>&lt;router-view&gt;</code>展示路由的地方，我们配置二级路由的路径时，写的就是一级路由下的。也就是说，虽然一级路由呈现的是layout组件，但它的路径仍然是&#x2F;src&#x2F;一级，二级路由的路径就是&#x2F;src&#x2F;一级&#x2F;二级。RouterView 组件可以使 Vue Router 知道你想要在哪里渲染当前 URL 路径对应的路由组件。一个路由（父路由）可以包含一个或多个嵌套的子路由。每个子路由都对应一个视图组件，这些子视图组件会被渲染到父视图组件的<code>&lt;router-view&gt;</code>。</p><h3 id="静态页面搭建主要用到以下几个el组件"><a href="#静态页面搭建主要用到以下几个el组件" class="headerlink" title="静态页面搭建主要用到以下几个el组件"></a>静态页面搭建主要用到以下几个el组件</h3><h4 id="pagination分页器"><a href="#pagination分页器" class="headerlink" title="pagination分页器"></a>pagination分页器</h4><p><a href="https://element-plus.org/zh-CN/component/pagination.html#pagination-%E5%88%86%E9%A1%B5">https://element-plus.org/zh-CN/component/pagination.html#pagination-%E5%88%86%E9%A1%B5</a><br>v-model:current-page:设置分页器当前页码<br>v-model:page-size:设置每一个展示数据条数<br>page-sizes:用于设置下拉菜单数据<br>background:设置分页器按钮的背景颜色<br>layout:可以设置分页器六个子组件布局调整</p><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p><a href="https://element-plus.org/zh-CN/component/table.html#table-%E8%A1%A8%E6%A0%BC">https://element-plus.org/zh-CN/component/table.html#table-%E8%A1%A8%E6%A0%BC</a><br>表格组件：用于展示已有得平台数据<br>table:—border:可以设置表格纵向是否有边框<br>table-column:—label:某一个列表 —width:设置这列宽度 —align:设置这一列对齐方式</p><h4 id="card卡片"><a href="#card卡片" class="headerlink" title="card卡片"></a>card卡片</h4><p><a href="https://element-plus.org/zh-CN/component/card.html#card-%E5%8D%A1%E7%89%87">https://element-plus.org/zh-CN/component/card.html#card-%E5%8D%A1%E7%89%87</a></p><h3 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h3><p>大致思路：我们拿到接口后，需要在&#x2F;src&#x2F;api中封装相关请求配置。首先在index.ts文件中枚举品牌管理的接口地址，然后封装获取已有品牌的接口方法；添加与修改已有品牌接口方法；删除某一个已有品牌的数据的方法.在type.ts文件中定义相关数据类型。接着在相关组件中就可以引入该文件后，使用这些方法发送请求，获得商品信息后渲染到组件中。<br>遇到的问题：<br>1.代理跨域<br>用脚手架写的项目：在config.js中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      &#x27;/api&#x27;: &#123;</span><br><span class="line">        target: &#x27;http://your-api-server.com&#x27;, // 目标服务器地址</span><br><span class="line">        changeOrigin: true, // 是否改变源地址</span><br><span class="line">        pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125; // 路径重写规则</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个配置中，所有以&#x2F;api开头的请求都会被代理到<a href="http://your-api-server.com上,并且会去掉/api%E5%89%8D%E7%BC%80%E3%80%82">http://your-api-server.com上，并且会去掉/api前缀。</a><br>配置好代理后，前端代码就可以像访问同域资源一样访问跨域资源了。<br>使用Axios、Fetch API等发起请求时，只需将URL设置为代理规则中定义的路径（如&#x2F;api&#x2F;xxx）。<br>用vite：在config.ts中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">  &quot;/api/admin/acl&quot;: &#123; // 更新代理规则以匹配新的路径</span><br><span class="line">    target: &quot;http://sph-api.atguigu.cn&quot;, // 目标后端服务</span><br><span class="line">    changeOrigin: true,</span><br><span class="line">    rewrite: (path) =&gt; path.replace(/^\/api/, &#x27;&#x27;),</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;/api&quot;: &#123;</span><br><span class="line">    //获取数据的服务器地址设置</span><br><span class="line">    target: &quot;http://39.98.123.211:8510&quot;,</span><br><span class="line">    //需要代理跨域</span><br><span class="line">    changeOrigin: true,</span><br><span class="line">    //路径重写</span><br><span class="line">    rewrite: (path) =&gt; path.replace(/^\/api/, &#x27;&#x27;),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：<br>第一个代理规则：<br>路径匹配：&#x2F;api&#x2F;admin&#x2F;acl<br>目标服务器：<a href="http://sph-api.atguigu.cn/">http://sph-api.atguigu.cn</a><br>changeOrigin: true：表示会改变请求的源地址（即Host头），这对于虚拟主机场景是必需的。<br>rewrite函数：将请求路径中的&#x2F;api前缀替换为空字符串（实际上，由于路径是&#x2F;api&#x2F;admin&#x2F;acl，它会匹配并替换开头的&#x2F;api&#x2F;部分，但在这个特定例子中，由于路径已经包含更具体的&#x2F;admin&#x2F;acl后缀，所以替换后的路径将是&#x2F;admin&#x2F;acl）。不过，这里的rewrite函数可以更精确地写为path.replace(&#x2F;^/api/admin/acl&#x2F;, ‘&#x2F;admin&#x2F;acl’)（但这样做是多余的，因为当路径完全匹配时，替换为空字符串也能达到相同效果，只要后端服务期望的路径是&#x2F;admin&#x2F;acl）。<br>第二个代理规则：<br>路径匹配：&#x2F;api（这是一个更通用的匹配模式，会匹配所有以&#x2F;api开头的路径）<br>目标服务器：<a href="http://39.98.123.211:8510/">http://39.98.123.211:8510</a><br>changeOrigin: true：同样表示会改变请求的源地址。<br>rewrite函数：将请求路径中的&#x2F;api前缀替换为空字符串。这意味着，如果请求的路径是&#x2F;api&#x2F;some&#x2F;endpoint，那么代理后的路径将是&#x2F;some&#x2F;endpoint。<br><strong>每个请求都会根据它的路径被代理到相应的后端服务，但每个请求只会被代理一次。</strong><br>2.向尚硅谷服务器发送请求Host: localhost:5173为什么是本地服务器<br>3.分页器不显示，检查后端返回的数据total<br>4.<code>&lt;el-table&gt;</code>的使用<br>5.当用ref监测请求返回的数组时，分页器可以正常运作；但用reactive就无法运作<br>答：因为新的数组不是响应式的，所以被赋值的数组也不会保留响应式的属性，你可以这样做reactiveArray &#x3D; reactive([4, 5, 6]); &#x2F;&#x2F; 新的数组也是响应式的<br>好像不太对呢？？？？？？<br>组件pagination父组件回传了数据(当前的页码)</p><h2 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h2><p>需要用到el-form的API以及一些方法;需要注意一个问题，就是清除表单数据的结果的时机，初次点击添加品牌时，表单元素还未生成，此时loginForm.value.clearValidate(‘logoUrl’)的返回值是undefined；因此我们有两个方法避免这个问题：<br>1.ts的写法：loginForm.value?.clearValidate(‘logoUrl’)<br>2.更新后的数据<br>nextTick(()&#x3D;&gt;{<br>  loginForm.value.clearValidate(‘tmName’)<br>})</p><h2 id="品牌管理模块删除业务"><a href="#品牌管理模块删除业务" class="headerlink" title="品牌管理模块删除业务"></a>品牌管理模块删除业务</h2><p>这里遇到的困难还是和ts数据类型的定义有关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table-column label=&quot;品牌操作&quot;&gt;</span><br><span class="line">  &lt;template #default=&quot;&#123;row&#125;&quot;&gt;</span><br><span class="line">    &lt;el-button icon=&quot;Edit&quot; @click=&quot;editLogo(row)&quot;&gt;&lt;/el-button&gt;</span><br><span class="line">    &lt;!-- 删除按钮的气泡框 --&gt;</span><br><span class="line">      &lt;el-popover :visible=&quot;visible[row.id]&quot; placement=&quot;top&quot; :width=&quot;160&quot;&gt;</span><br><span class="line">        &lt;p&gt;确定要删除该品牌的信息吗？&lt;/p&gt;</span><br><span class="line">        &lt;div style=&quot;text-align: right; margin: 0&quot;&gt;</span><br><span class="line">          &lt;el-button size=&quot;small&quot; @click=&quot;missdeleteLogo(row.id)&quot;&gt;取消&lt;/el-button&gt;</span><br><span class="line">          &lt;el-button size=&quot;small&quot; type=&quot;primary&quot; @click=&quot;confirmdeleteLogo(row.id)&quot;&gt;确认&lt;/el-button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;template #reference&gt;</span><br><span class="line">          &lt;el-button icon=&quot;Delete&quot; @click=&quot;deleteLogo(row.id)&quot;&gt;&lt;/el-button&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">      &lt;/el-popover&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/el-table-column&gt;</span><br></pre></td></tr></table></figure><p>这里我们不能直接把气泡框的状态用点击按钮进行切换，因为这样会使整个页面的气泡框处于一个共享的状态，一旦有一个出现，其他也会出现。因此我们应该绑定事件，并传入id。<br><code>let visible = ref&lt;boolean[]&gt;([])</code>状态数组的定义<code>visible.value[id] = false</code>状态数组的访问</p><h2 id="属性管理模块数据展示"><a href="#属性管理模块数据展示" class="headerlink" title="属性管理模块数据展示"></a>属性管理模块数据展示</h2><p>基本流程：当选定一级数据后根据一级的id才会有二级的数据，二级的数据选定后根据二级的id才会有三级的数据，三级的数据选定后才会有下面页面的展示。<br>基本思路：因为很多组件都会用到关于属性的数据，所以我们把它存入仓库中。在属性管理模块，当页面挂载完成时，应该发送请求获取一级数据，并将其还有一级id存入仓库中;一级数据选择完毕后，带着一级的id发送请求获取二级数据，并将其还有二级id存入仓库中；以此类推。因为数据要存储在仓库中，在在仓库中定义一个发送请求的函数方便赋值，在组件中直接调用即可。<br>如何知道是否获取某一级的id?答：可以用change事件，绑定一个回调函数。当select框的选中值发生变化时，触发事件。（当用户从下拉菜单中选择一个选项时，<code>&lt;el-select&gt;</code> 的 v-model 绑定的值会自动更新为被选中 <code>&lt;el-option&gt;</code>的 value 值。）<br>下面的展示模块：<br>将发送请求得到的数组存入当前组件的响应式数组中，然后给el-table元素中注入 data 对象数组后，每一列进行相应的遍历可以用prop或插槽<br>#default: 这是v-slot指令的缩写形式，其中#是v-slot:的简写。default指的是默认插槽的名称<br>{row}: 这是传递给插槽的作用域（scope），它定义了一个名为row的变量，这个变量在插槽的内容中可用。作用域插槽允许子组件将数据传递给父组件的插槽内容。</p><h2 id="属性管理模块数据管理"><a href="#属性管理模块数据管理" class="headerlink" title="属性管理模块数据管理"></a>属性管理模块数据管理</h2><p>当进入添加属性模块时，上面的三个下拉菜单被禁用，父子之间通信，用props，definepropty</p><p>添加新的属性的业务：利用表单收集，需要收集的数据有：新增属性的名字,新增的属性值数组,三级分类的id(具体给哪个物品添加属性)<br>属性名字利用v-model收集即可；<br>新增的属性值数组的收集就是每点击一次新增属性按钮，就把input收集到的v-model，Push进数组即可。<br>三级分类的id因为是存在仓库中，所以很容易被访问到。<br><strong>清空上次遗留的数据</strong>在每次点击新增属性按钮后，清空组件定义的ref对象的数据；Object.assign() 是 JavaScript 中的一个方法，用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。该方法主要用于对象合并或属性的浅拷贝。<br>收集完发请求。</p><p>添加属性的input和div的切换:还有两个特殊情况，当input为空时，不能切换；当input的内容和前面的有重复时，不能切换。</p><p>添加属性值的编辑模式：自动聚焦：1.当点击添加属性值按钮时，表单收集的数组的最后一个input元素自动聚焦。2.点击某个input元素（由div切换至input时），自动聚焦。<br>这个功能主要用到的思路是：利用ref获取input的dom元素，存在一个数组中。并且input有一个focus属性，可以聚焦，当出现上述两种情况时，用focus聚焦即可。并且，因为渲染页面需要一定的时间，我们不能立刻获取到dom元素，所以要使用nextTick，等页面数据更新完毕之后再进行更改。</p><p>属性值的编辑模式：当点击编辑按钮时，视图切换，与上述不同的是，需要把当前物品的所有属性在表格中做一个呈现。之前，在el-table上我们绑定的数组attrParams.attrValueList，用作添加新的属性的呈现，现在可以在点击编辑按钮时把当前的属性值（row）赋值给该数组。<strong>注意</strong>：这里如果直接用Object.assign()，就会导致浅拷贝，也就是当你编辑新的属性值的时候，即使未点击保存，也会将已经写入的属性值添加到数组中，在查看模式中呈现出来。因此我们这里需要用到的是深拷贝。 <code>Object.assign(attrParams,JSON.parse(JSON.stringify(row)))</code><br>JSON.stringify(row)：这个方法将 row 对象转换成一个 JSON 字符串。这个过程是深拷贝的一部分，因为它创建了一个完全独立的字符串表示。<br>JSON.parse(…)：这个方法将上一步生成的 JSON 字符串解析回一个 JavaScript 对象。因为这是一个<strong>全新的对象</strong>，所以这是一个深拷贝的过程，它创建了 row 的一个完全独立的副本。<br>Object.assign(attrParams, …)：这个方法将上一步创建的 row 的深拷贝对象的所有可枚举属性复制到 attrParams 对象中。如果 attrParams 和深拷贝对象有相同的属性，则 attrParams 中的属性值将被深拷贝对象的属性值覆盖。</p><h2 id="SPU模块"><a href="#SPU模块" class="headerlink" title="SPU模块"></a>SPU模块</h2><p>当进入spu组件时，点击取消按钮后，要返回到spu模块的主页面，需要场景切换。但是spu组件是子组件，要给父index传数据，我们可以采用自定义事件。在父组件中，子组件的实例对象身上绑定一个自定义事件并让他等于父组件的一个回调函数，在子组件中用defineprops接收后，调用并传递参数。</p><h3 id="index的编辑模式："><a href="#index的编辑模式：" class="headerlink" title="index的编辑模式："></a>index的编辑模式：</h3><p>当点击编辑按钮时，场景切换，同时，还需要把当前品牌的数据渲染在页面中。但是我们拿到的数据是不完整的，还需要再发四个请求获得：全部品牌信息，商品图片，商品属性，商品的全部属性。<br>首先我们要考虑什么时候发送请求拿到数据然后渲染页面：<br>页面挂载时？答案是否定的，因为组件用的是v-show，也就意味着当父组件挂载完毕时，子组件也已经存在。这时候无法发送请求，因为可能还没有拿到三级数据的ID,所以pass。<br>点击编辑按钮时？当点击编辑按钮时，发送请求。我们要考虑的就是，数据应该在子组件中被拿到，然后呈现在页面上。因为如果在父组件中拿到的话，还要把数据传给子组件，就非常麻烦，因此我们需要做到<strong>在子组件中发送请求</strong>拿到数据。可是，点击编辑按钮时的row的数据还要再传给子组件吗？我们有另一个办法！用<strong>ref</strong>，获取到子组件的dom元素，这也就意味着，我们可以在父组件中随意的使用子组件身上的任何属性和方法。接着，在子组件内部定义一个方法，发送请求获取数据，**记得要对外暴露！defineExpose({sendreq})**至于row，我们可以用父组件调用该方法时传递参数给子组件。</p><h3 id="计算当前SPU还未拥有的销售属性"><a href="#计算当前SPU还未拥有的销售属性" class="headerlink" title="计算当前SPU还未拥有的销售属性"></a>计算当前SPU还未拥有的销售属性</h3><p>Array.prototype.every() 是 JavaScript 中数组的一个方法，用于测试数组的所有元素是否都通过了由提供的函数实现的测试。如果数组中所有元素都通过了测试，则返回 true，否则返回 false。<br>Array.prototype.filter() 是 JavaScript 数组的一个方法，它用于创建一个新数组，这个新数组包含通过所提供函数实现的测试的所有元素。简而言之，filter 方法会遍历数组中的每一个元素，并应用一个测试函数（回调函数），将返回 true 的元素添加到新数组中，最终返回这个新数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let unSelectSaleAttr = computed(()=&gt;&#123;</span><br><span class="line">  let unSelectArr = AllAttrs.value.filter(item=&gt;&#123;//所有的属性：颜色，尺寸</span><br><span class="line">    return Attrs.value.every(item1=&gt;&#123;//该商品的属性：颜色</span><br><span class="line">      return item.name != item1.saleAttrName</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  return unSelectArr</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>并且使用:value和v-model把没有被选择的属性的编号以及属性名收集。为了方便点击添加属性按钮时的操作，我们可以把收集好的数据封装成一个对象，然后直接push进数组即可。</p><h3 id="添加属性值模块："><a href="#添加属性值模块：" class="headerlink" title="添加属性值模块："></a>添加属性值模块：</h3><p>·添加属性值：需要给input绑定一个变量，收集数据，我们需要收集属性值的值，以及属性ID（给哪个属性添加的值），因为要把数据带给服务器，所以收集好之后，要封装成一个符合服务器字段名的对象，并推进数组<br>·切换按钮和input框：设置一个变量即可，还需要把上次input收集到的数据清空<br>·属性值不能为空trim()，不能重复find的判断<br>·数据收集完毕，发送请求。因为照片墙部分将属性名改了，所以还要再改回来。</p><h3 id="添加新的属性："><a href="#添加新的属性：" class="headerlink" title="添加新的属性："></a>添加新的属性：</h3><p>在子组件上定义一个方法，用来发送请求。在父组件中，用ref获取到子组件的组件实例对象后，调用该方法，发送请求。但是，我们需要点明是在哪个商品上添加的属性，所以需要父组件把c3id传给子组件。然后只需要发送两个请求，获取其他品牌和销售属性即可，剩下的数据都是需要被收集后发送post请求带上去的。还有就是一些清空业务。</p><h2 id="SKU模块"><a href="#SKU模块" class="headerlink" title="SKU模块"></a>SKU模块</h2><h3 id="获取SKU数据"><a href="#获取SKU数据" class="headerlink" title="获取SKU数据"></a>获取SKU数据</h3><p>与spu相同，我们想在点击增加sku按钮时，切换场景：在父组件中的子组件实例对象上绑定一个自定义事件，并带参数，当在子组件中点击取消按钮时，触发自定义事件，改变场景值即可。<br>·获取sku数据：我们想在父组件中点击添加按钮后，就发送请求，可是数据应该出现在子组件中。所以我们在父组件中用ref获取子组件实例对象，在子组件中定义一个发送请求的方法，并<strong>暴露</strong>(defineExpose({sendreq}))，在父组件中就可以调用该方法来发送请求，而数据在子组件中被获得。<br>数据收集到一个ref对象上;其中收集平台属性和销售属性时，先把每个属性值收集到属性对象的attrIdAndValueId上，因为我们当时定义ts类型时，将这两个数据的具体的值归为一个数组，所以需要我们全部收集完后再整理为一个数组发送给服务器。在这里我们要收集的是，属性id和属性值id，所以在option上的value绑定的是<code>$&#123;item.id&#125;:$&#123;it.id&#125;</code>然后利用v-model收集到select上绑定数据到属性对象的attrIdAndValueId上。<br>·设置默认图片，前面复选框自动勾选：首先我们要用ref获取table实例，然后用<strong>table</strong>的**toggleRowSelection(row,true)**方法（用于多选表格，切换某一行的选中状态， 如果使用了第二个参数，则可直接设置这一行选中与否）。给设置默认事件绑定点击按钮，由于只能有一个被选中，因此我们先遍历（保存的图片的数组）将其他的设为false，然后再将被选中的设为true。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const handler=(row:any)=&gt;&#123;</span><br><span class="line">  //收集默认图片的路径</span><br><span class="line">  skuParams.skuDefaultImg=row.imgUrl</span><br><span class="line">  //关于复选框</span><br><span class="line">  //点击的时候，全部图片的复选框均不勾选</span><br><span class="line">  Photos.value.forEach((item:any)=&gt;&#123;</span><br><span class="line">    table.value.toggleRowSelection(item,false)</span><br><span class="line">    console.log(item)</span><br><span class="line">  &#125;)</span><br><span class="line">  //被选中的图片的复选框勾选</span><br><span class="line">  table.value.toggleRowSelection(row,true)</span><br><span class="line">  console.log(row)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意，因为给table绑定的:data是图片数组，所以row是和item的元素是一样的。<br>·整理平台属性和销售属性的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let AttrArrs = AttrArr.value.reduce((prev:any,next:any)=&gt;&#123;</span><br><span class="line">  if(next.attrIdAndValueId)&#123;</span><br><span class="line">    let [attrId,valueId] = next.attrIdAndValueId.split(&#x27;:&#x27;)//那么使用split(&#x27;:&#x27;)方法将其值按冒号:分割成一个数组，并将这个数组解构为两个变量：attrId和valueId。</span><br><span class="line">    prev.push(&#123;</span><br><span class="line">      attrId,</span><br><span class="line">      valueId</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  return prev</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure><p><code>let [attrId,valueId] = next.attrIdAndValueId.split(&#39;:&#39;)</code><br>使用split(‘:’)方法将其值按冒号:分割成一个数组，并将这个数组解构为两个变量：attrId和valueId<br>回调函数返回prev，即更新后的累加器数组。这确保了reduce方法在下一次迭代时能够使用最新的数组。<br>关于reduce函数<br><code>array.reduce(callback(accumulator, currentValue, currentIndex, array), initialValue)</code><br>callback（必需）：一个执行数组中每个元素的函数，包含四个参数：<br>accumulator（累加器）：上一次调用回调时返回的累积值，或 initialValue（如果提供了 initialValue）。<br>currentValue（当前值）：数组中正在处理的当前元素。<br>currentIndex（当前索引）：数组中正在处理的当前元素的索引。如果提供了 initialValue，则从索引 0 开始；否则从索引 1 开始。<br>array（数组）：调用 reduce 的数组。<br>initialValue（可选）：作为第一次调用 callback 函数时的第一个参数的值。如果没有提供 initialValue，则将数组的第一个元素作为第一次调用 callback 的第一个参数，并且跳过数组的第一个元素，从第二个元素开始累加。</p><h2 id="用户管理模块"><a href="#用户管理模块" class="headerlink" title="用户管理模块"></a>用户管理模块</h2><h3 id="增加新账号和修改账号"><a href="#增加新账号和修改账号" class="headerlink" title="增加新账号和修改账号"></a>增加新账号和修改账号</h3><p>这里需要注意的就是：<br>1.每次点击增加新用户时，需要清空上次收集到的数据：用到了Object.assign(),还有清空表单项的校验提示信息。当页面挂载后，组件中并没有抽屉这个元素，因此我们应该用nextTick(),等页面把数据更新完毕后，再获取到表单项，用clearValidate清除。<br>2.当我们修改自己的账户信息时，原来的账号已经不存在，因此我们需要被重新登陆，用<code> window.location.reload()</code>该方法使浏览器自动刷新一次，利用当时我们写的路由守卫，被反弹到登录页面。</p><h3 id="用户管理的重置"><a href="#用户管理的重置" class="headerlink" title="用户管理的重置"></a>用户管理的重置</h3><p>用到的方法是仓库的reset</p><h3 id="分配权限"><a href="#分配权限" class="headerlink" title="分配权限"></a>分配权限</h3><p>当页面需要呈现出被选择用户的所有权限时，我们得到的数组需要被递归，因为结构一样，但是子数组中又有子数组，所以采用递归思想。并且，要想得到正确的被勾选的形式需要获取到level为4并且selection 为true 的id，并记录下来。</p><p>在JavaScript或TypeScript中，当你处理对象和变量时，赋值方式的选择会直接影响对象的引用和内容的更新。在你提供的代码片段中，你展示了两种清空MenuData对象属性的方法，并询问为什么使用第二种方法（直接赋值整个对象）会导致input无法呈现输入的值。</p><p>首先，我们需要明确一点：在你的代码中，MenuData很可能是一个响应式对象，特别是在你使用Vue或类似框架时。响应式对象通常具有特殊的getter和setter，以便在属性被访问或修改时触发更新。</p><p>使用 Object.assign()<br>javascript<br>Object.assign(MenuData, {<br>    code: ‘’,<br>    id: 0,<br>    level: 0,<br>    name: ‘’,<br>    pid: 0<br>});<br>当你使用Object.assign()时，你是在修改MenuData对象的现有实例。你并没有创建一个新的对象，而是将新属性复制到现有的MenuData对象中。这意味着MenuData的引用保持不变，但它的内容被更新了。由于MenuData是响应式的，Vue或类似框架能够检测到这些变化，并更新依赖于MenuData的任何视图或组件。</p><p>直接赋值整个对象<br>javascript<br>MenuData &#x3D; {<br>    code: ‘’,<br>    id: 0,<br>    level: 0,<br>    name: ‘’,<br>    pid: 0<br>};<br>当你直接赋值整个对象时，你实际上是在创建一个新的对象，并将其赋值给MenuData变量。这意味着MenuData现在指向一个新的对象引用，而不是原来的响应式对象。如果MenuData是在Vue组件的data函数中定义的，并且被用作响应式数据，那么这种赋值方式会破坏响应性。Vue将无法追踪新对象的属性变化，因为新对象没有Vue的响应式getter和setter。</p><p>为什么input无法呈现输入的值？<br>当你直接赋值整个对象时，如果MenuData是响应式的，并且你在模板中绑定了MenuData的某个属性到input的值，那么由于MenuData现在指向一个新的非响应式对象，Vue无法检测到属性的变化。因此，当你在input中输入值时，这个值不会被同步到新的MenuData对象中，也不会更新到Vue的响应式系统中。</p><h2 id="当切换路由时，路由切换成功但是页面上的组件不显示"><a href="#当切换路由时，路由切换成功但是页面上的组件不显示" class="headerlink" title="当切换路由时，路由切换成功但是页面上的组件不显示"></a>当切换路由时，路由切换成功但是页面上的组件不显示</h2><p><a href="https://blog.csdn.net/weixin_43185419/article/details/131187369">https://blog.csdn.net/weixin_43185419/article/details/131187369</a><br><keep-alive> 用于缓存组件实例，保留组件的状态，适用于需要保留用户输入或避免重复数据获取的场景。<br>在 <router-view> 上添加 :key 用于强制重新渲染组件，解决状态不一致的问题，适用于路由参数变化需要重置组件状态的场景。</router-view></keep-alive></p><h3 id="菜单管理"><a href="#菜单管理" class="headerlink" title="菜单管理"></a>菜单管理</h3><p>我们把路由分为三种：常量路由（任何用户都可以访问），异步路由（有人可以有人不可以），任意路由。<br>在登录发送请求时，我们可以获取到用户的所带路由的信息（用户被分配的权限，权限的名字就是路由的名字），拿用户可以访问的路由信息数组和我们定义的异步路由的数组进行对比，过滤出用户所拥有的路由权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function filterAsyncRoute(asnycRoute: any, routes: any) &#123;</span><br><span class="line">  return asnycRoute.filter((item: any) =&gt; &#123;</span><br><span class="line">    if (routes.includes(item.name)) &#123;</span><br><span class="line">      if (item.children &amp;&amp; item.children.length &gt; 0) &#123;</span><br><span class="line">        //硅谷333账号:product\trademark\attr\sku</span><br><span class="line">        item.children = filterAsyncRoute(item.children, routes)</span><br><span class="line">      &#125;</span><br><span class="line">      return true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时需要深拷贝</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const userAsyncRoute = filterAsyncRoute(</span><br><span class="line">  cloneDeep(asyncRoute),</span><br><span class="line">  result.data.routes,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后追加到用户信息仓库的路由信息中<code>this.menuRoutes = [...constantRoutes, ...userAsyncRoute, ...anyRoute];</code><br>但是此时并没有注册除常量路由以外的路由，所以我们还需要将获得的路由数组注册</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[...userAsyncRoute, anyRoute].forEach((route: any) =&gt; &#123;</span><br><span class="line">  router.addRoute(route)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="echarts使用步骤以及常用配置项"><a href="#echarts使用步骤以及常用配置项" class="headerlink" title="echarts使用步骤以及常用配置项"></a>echarts使用步骤以及常用配置项</h2><p>1.获取dom元素， <code>ref=&quot;charts&quot;</code>  <code>let charts = ref()</code><br>2.引入echarts <code>import * as echarts from &#39;echarts&#39;;</code><br>3.初始化 <code>let mycharts = echarts.init(charts.value)</code><br>4.设置配置项 <code>mycharts.setOption(option)</code></p><h3 id="常见的配置项"><a href="#常见的配置项" class="headerlink" title="常见的配置项"></a>常见的配置项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;</span><br><span class="line">  text: &#x27;主标题&#x27;,</span><br><span class="line">  subtext: &#x27;副标题&#x27;,</span><br><span class="line">  left: &#x27;center&#x27;, // 标题水平位置：&#x27;left&#x27; | &#x27;center&#x27; | &#x27;right&#x27;</span><br><span class="line">  textStyle: &#123; fontSize: 18, color: &#x27;#333&#x27; &#125;, // 主标题样式</span><br><span class="line">  subtextStyle: &#123; fontSize: 14, color: &#x27;#999&#x27; &#125;, // 副标题样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>管理图表系列的展示和交互</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">legend: &#123;</span><br><span class="line">  orient: &#x27;horizontal&#x27;, // 布局方向：&#x27;horizontal&#x27;(水平的) | &#x27;vertical&#x27;</span><br><span class="line">  left: &#x27;center&#x27;,</span><br><span class="line">  data: [&#x27;系列1&#x27;, &#x27;系列2&#x27;], // 对应 series.name</span><br><span class="line">  textStyle: &#123; color: &#x27;#000&#x27; &#125;, // 图例文字样式</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>tooltip（提示框）<br>显示鼠标悬浮时的数据详情。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tooltip: &#123;</span><br><span class="line">  trigger: &#x27;item&#x27;, // &#x27;item&#x27;: 针对数据项 | &#x27;axis&#x27;: 针对坐标轴</span><br><span class="line">  formatter: &#x27;&#123;a&#125; &lt;br/&gt;&#123;b&#125;: &#123;c&#125; (&#123;d&#125;%)&#x27;, // 自定义格式化内容</span><br><span class="line">  backgroundColor: &#x27;rgba(50,50,50,0.7)&#x27;, // 提示框背景色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>grid（网格）<br>设置坐标系在容器中的布局。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">grid: &#123;//饼状图中在legnd中设置</span><br><span class="line">  left: &#x27;10%&#x27;, // 距左边距</span><br><span class="line">  right: &#x27;10%&#x27;, // 距右边距</span><br><span class="line">  top: &#x27;15%&#x27;, // 距顶部</span><br><span class="line">  bottom: &#x27;10%&#x27;, // 距底部</span><br><span class="line">  containLabel: true, // 是否包含坐标轴刻度标签</span><br><span class="line">  containLabel: true//保证折线图的数据从 X 轴的起点开始绘制，避免视觉上的留白问题。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xAxis: &#123;</span><br><span class="line">  type: &#x27;category&#x27;, // 坐标轴类型：&#x27;value&#x27;（数值） | &#x27;category&#x27;（类目） | &#x27;time&#x27;（时间）</span><br><span class="line">  data: [&#x27;周一&#x27;, &#x27;周二&#x27;, &#x27;周三&#x27;], // 类目数据</span><br><span class="line">  axisLine: &#123; lineStyle: &#123; color: &#x27;#333&#x27; &#125; &#125;, // 坐标轴线样式</span><br><span class="line">  axisLabel: &#123; color: &#x27;#666&#x27; &#125; // 标签样式</span><br><span class="line">&#125;,</span><br><span class="line">yAxis: &#123;</span><br><span class="line">  type: &#x27;value&#x27;,</span><br><span class="line">  splitLine: &#123; lineStyle: &#123; type: &#x27;dashed&#x27;, color: &#x27;#ddd&#x27; &#125; &#125;, // 网格线样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 硅谷甄选 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目中常用到的</title>
      <link href="/2024/11/10/guigu/"/>
      <url>/2024/11/10/guigu/</url>
      
        <content type="html"><![CDATA[<h1 id="应用Element-plus插件"><a href="#应用Element-plus插件" class="headerlink" title="应用Element-plus插件"></a>应用Element-plus插件</h1><p>插件被重复使用,国际化应用失败也是这里出错<br><img src="/2024/11/10/guigu/4.png" alt="alt text"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(ElementPlus)</span><br><span class="line">app.use(ElementPlus, &#123;</span><br><span class="line">  locale: zhCn,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="安装sass遇到的问题"><a href="#安装sass遇到的问题" class="headerlink" title="安装sass遇到的问题"></a>安装sass遇到的问题</h1><p><img src="/2024/11/10/guigu/image.png" alt="alt text"><br>我们目前在组件内部已经可以使用scss样式,因为在配置styleLint工具的时候，项目当中已经安装过sass sass-loader,因此我们再组件内可以使用scss语法！！！需要加上lang&#x3D;”scss”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped lang=&quot;scss&quot;&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>接下来我们为项目添加一些全局的样式<br>在src&#x2F;styles目录下创建一个index.scss文件，当然项目中需要用到清除默认样式，因此在index.scss引入reset.scss</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import reset.scss</span><br></pre></td></tr></table></figure><p>在入口文件引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;@/styles&#x27;</span><br></pre></td></tr></table></figure><p>但是你会发现在src&#x2F;styles&#x2F;index.scss全局样式文件中没有办法使用$变量.因此需要给项目中引入全局变量$.<br>在style&#x2F;variable.scss创建一个variable.scss文件！<br>在vite.config.ts文件配置如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default defineConfig((config) =&gt; &#123;</span><br><span class="line">css: &#123;</span><br><span class="line">      preprocessorOptions: &#123;</span><br><span class="line">        scss: &#123;</span><br><span class="line">          javascriptEnabled: true,</span><br><span class="line">          additionalData: &#x27;@import &quot;./src/styles/variable.scss&quot;;&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><code>@import &quot;./src/styles/variable.less&quot;;</code>后面的<code>;</code>不要忘记，不然会报错</strong>!</p><h2 id="治标不治本的两个方法："><a href="#治标不治本的两个方法：" class="headerlink" title="治标不治本的两个方法："></a>治标不治本的两个方法：</h2><p>1.把sass变量在需要使用的组件中再次声明<br><img src="/2024/11/10/guigu/3.png" alt="alt text"><br>2.把@use换成@import 但会有警告，因为@import已经弃用</p><h1 id="找不到模块问题"><a href="#找不到模块问题" class="headerlink" title="找不到模块问题"></a>找不到模块问题</h1><p><img src="/2024/11/10/guigu/2.png" alt="alt text"><br>在vue3项目里，ts文件是识别不了vue文件<br>找到项目的env.d.ts文件<br>加上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declare module &quot;*.vue&quot; &#123;</span><br><span class="line">  import type &#123; DefineComponent &#125; from &quot;vue&quot;;</span><br><span class="line">  const vueComponent: DefineComponent&lt;&#123;&#125;, &#123;&#125;, any&gt;;</span><br><span class="line">  export default vueComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="moke接口"><a href="#moke接口" class="headerlink" title="moke接口"></a>moke接口</h1><p>安装依赖:<a href="https://www.npmjs.com/package/vite-plugin-mock">https://www.npmjs.com/package/vite-plugin-mock</a><br>通过命令行 npm install -D vite-plugin-mock mockjs 安装的vite-plugin-mock 之后发现再vite.config.ts里边报错<br>viteMockServe({ localEnabled: command &#x3D;&#x3D;&#x3D; ‘serve’, })  类型“{ localEnabled: boolean; }”的参数不能赋给类型“ViteMockOptions”的参数。<br>对象字面量只能指定已知属性，并且“localEnabled”不在类型“ViteMockOptions”中。<br>解决办法：<br>卸载vite-plugin-mock</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall vite-plugin-mock</span><br></pre></td></tr></table></figure><p>安装 2.9.6版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mockjs vite-plugin-mock@2.9.6 -D</span><br></pre></td></tr></table></figure><p>为啥发送get 请求就获取不到信息</p><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p><strong>项目开发过程中，至少会经历开发环境、测试环境和生产环境(即正式环境)三个阶段。不同阶段请求的状态(如接口地址等)不尽相同，若手动切换接口地址是相当繁琐且易出错的。于是环境变量配置的需求就应运而生，我们只需做简单的配置，把环境状态切换的工作交给代码。</strong></p><p>开发环境（development）<br>顾名思义，开发使用的环境，每位开发人员在自己的dev分支上干活，开发到一定程度，同事会合并代码，进行联调。</p><p>测试环境（testing）<br>测试同事干活的环境啦，一般会由测试同事自己来部署，然后在此环境进行测试</p><p>生产环境（production）<br>生产环境是指正式提供对外服务的，一般会关掉错误报告，打开错误日志。(正式提供给客户使用的环境。)</p><p>注意:一般情况下，一个环境对应一台服务器,也有的公司开发与测试环境是一台服务器！！！</p><p>项目根目录分别添加 开发、生产和测试环境的文件!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.env.development</span><br><span class="line">.env.production</span><br><span class="line">.env.test</span><br></pre></td></tr></table></figure><p>文件内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 变量必须以 VITE_ 为前缀才能暴露给外部读取</span><br><span class="line">NODE_ENV = &#x27;development&#x27;</span><br><span class="line">VITE_APP_TITLE = &#x27;硅谷甄选运营平台&#x27;</span><br><span class="line">VITE_APP_BASE_API = &#x27;/dev-api&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV = &#x27;production&#x27;</span><br><span class="line">VITE_APP_TITLE = &#x27;硅谷甄选运营平台&#x27;</span><br><span class="line">VITE_APP_BASE_API = &#x27;/prod-api&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 变量必须以 VITE_ 为前缀才能暴露给外部读取</span><br><span class="line">NODE_ENV = &#x27;test&#x27;</span><br><span class="line">VITE_APP_TITLE = &#x27;硅谷甄选运营平台&#x27;</span><br><span class="line">VITE_APP_BASE_API = &#x27;/test-api&#x27;</span><br></pre></td></tr></table></figure><p>配置运行命令：package.json</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;dev&quot;: &quot;vite --open&quot;,</span><br><span class="line">   &quot;build:test&quot;: &quot;vue-tsc &amp;&amp; vite build --mode test&quot;,</span><br><span class="line">   &quot;build:pro&quot;: &quot;vue-tsc &amp;&amp; vite build --mode production&quot;,</span><br><span class="line">   &quot;preview&quot;: &quot;vite preview&quot;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>通过import.meta.env获取环境变量</p><h1 id="axios-二次封装"><a href="#axios-二次封装" class="headerlink" title="axios 二次封装"></a>axios 二次封装</h1><p>目的：<br>1:使用请求拦截器，可以在请求拦截器中处理一些业务(开始进度条、请求头携带公共参数)<br>2:使用响应拦截器，可以在响应拦截器中处理一些业务(进度条结束、简化服务器返回的数据、处理http网络错误)<br>在根目录下创建utils&#x2F;request.ts<br>&#x2F;&#x2F;进行axios二次封装：使用请求与响应拦截器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">import Nprogress from &#x27;nprogress&#x27;</span><br><span class="line">import &#x27;nprogress/nprogress.css&#x27;</span><br><span class="line">import &#123; ElMessage &#125; from &#x27;element-plus&#x27;;</span><br><span class="line">let requests = axios.create(&#123;</span><br><span class="line">  //基础路径</span><br><span class="line">  baseURL: import.meta.env.VITE_APP_BASE_API,</span><br><span class="line">  timeout: 5000//超时时间设置</span><br><span class="line">&#125;);</span><br><span class="line">//第二步，给axios添加请求和响应拦截器</span><br><span class="line">requests.interceptors.request.use((config) =&gt; &#123;</span><br><span class="line">  //config,有headers请求头属性，给服务器携带公共参数</span><br><span class="line">  Nprogress.start();//核心代码</span><br><span class="line">  //返回配置对象</span><br><span class="line">  return config</span><br><span class="line">&#125;)</span><br><span class="line">//第三步：响应拦截器</span><br><span class="line">requests.interceptors.response.use((response) =&gt; &#123;</span><br><span class="line">  Nprogress.done()    //核心代</span><br><span class="line">  //成功的回调</span><br><span class="line">  //简化数据</span><br><span class="line">  return response.data</span><br><span class="line">&#125;, (error) =&gt; &#123;</span><br><span class="line">  //失败的回调</span><br><span class="line">  //定义一个变量，存储网络错误信息</span><br><span class="line">  let msg = &#x27;&#x27;;</span><br><span class="line">  let status = error.response.status;</span><br><span class="line">  switch (status) &#123;</span><br><span class="line">    case 401:</span><br><span class="line">      msg = &quot;token过期&quot;;</span><br><span class="line">      break;</span><br><span class="line">    case 403:</span><br><span class="line">      msg = &#x27;无权访问&#x27;;</span><br><span class="line">      break;</span><br><span class="line">    case 404:</span><br><span class="line">      msg = &quot;请求地址错误&quot;;</span><br><span class="line">      break;</span><br><span class="line">    case 500:</span><br><span class="line">      msg = &quot;服务器出现问题&quot;;</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      msg = &quot;无网络&quot;;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">//返回一个被拒绝的 Promise 对象。</span><br><span class="line">  ElMessage(&#123;</span><br><span class="line">    type: &#x27;error&#x27;,</span><br><span class="line">    message: msg</span><br><span class="line">  &#125;)</span><br><span class="line">  return Promise.reject(error);</span><br><span class="line">&#125;)</span><br><span class="line">export default requests;</span><br></pre></td></tr></table></figure><h1 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h1><p>1.安装依赖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm i nprogress -S</span><br></pre></td></tr></table></figure><p>2.引入进度条。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Nprogress from &#x27;nprogress&#x27;</span><br><span class="line">import &#x27;nprogress/nprogress.css&#x27;</span><br></pre></td></tr></table></figure><p>3.使用。<br>发送请求时，在request方法添加进度条。<br>&#x2F;&#x2F; request拦截器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">service.interceptors.request.use(</span><br><span class="line">    config =&gt; &#123;</span><br><span class="line">        Nprogress.start();//核心代码</span><br><span class="line">        return config;</span><br><span class="line">    &#125;, error =&gt; &#123;</span><br><span class="line">        Promise.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>请求响应时，在response方法撤销进度条。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// respone拦截器</span><br><span class="line">  Nprogress.done()    //核心代码</span><br></pre></td></tr></table></figure><h1 id="API接口统一管理"><a href="#API接口统一管理" class="headerlink" title="API接口统一管理"></a>API接口统一管理</h1><p>在&#x2F;src&#x2F;api&#x2F;user下<br>index.ts</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import requests from &quot;../../utils/request&quot;;</span><br><span class="line">import type &#123; loginForm, loginResponseData, userResponseData &#125; from &#x27;./type&#x27;</span><br><span class="line">//统一管理接口</span><br><span class="line">enum API &#123;</span><br><span class="line">  LOGIN_URL = &quot;/user/login&quot;,</span><br><span class="line">  USERINFO_URL = &quot;/user/info&quot;</span><br><span class="line">&#125;</span><br><span class="line">//暴露请求函数</span><br><span class="line">//登录接口方法</span><br><span class="line">export const reqLogin = (data: loginForm) =&gt; requests.post&lt;any, loginResponseData&gt;(API.LOGIN_URL, data)</span><br><span class="line">//获取用户信息接口方法</span><br><span class="line">export const reqUserInfo = requests.get&lt;any, userResponseData&gt;(API.USERINFO_URL)</span><br></pre></td></tr></table></figure><p>type.ts文件中定义相关数据类型</p><h1 id="如何注册一个全局组件？"><a href="#如何注册一个全局组件？" class="headerlink" title="如何注册一个全局组件？"></a>如何注册一个全局组件？</h1><p>1.在入口文件中引入<br>2.app.component(‘全局组件名’,引入组件名)<br>3.直接使用即可</p><h1 id="配置路由的基本流程"><a href="#配置路由的基本流程" class="headerlink" title="配置路由的基本流程"></a>配置路由的基本流程</h1><p>1.npm i vue-router<br>2.在src文件夹下创建一个router文件夹，index.ts<br>路由组件一般放在&#x2F;src&#x2F;pages文件夹下<br>3.在index.ts中引入createRouter方法，用于创建路由实例，需要暴露（因为在入口文件中需要被引入使用）<br>4.配置路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">export default createRouter(&#123;</span><br><span class="line">  //路由的模式设置</span><br><span class="line">  history: createWebHashHistory(),</span><br><span class="line">  //管理路由</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#x27;/home&#x27;,</span><br><span class="line">      component: () =&gt; import(&#x27;../pages/home/index.vue&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#x27;/hospital&#x27;,</span><br><span class="line">      component: () =&gt; import(&#x27;../pages/hospital/index.vue&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#x27;/&#x27;,</span><br><span class="line">      redirect: &#x27;/home&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  //滚动行为（控制滚动条的位置</span><br><span class="line">  scrollBehavior() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      left: 0,</span><br><span class="line">      top: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>5.在main.js引入router<br><code>import router from &#39;@/index.ts&#39;</code><br>安装vue-router<code>app.use(router)</code><br>6.设置展示路由组件的区域</p><h1 id="使用element-plus基本步骤"><a href="#使用element-plus基本步骤" class="headerlink" title="使用element-plus基本步骤"></a>使用element-plus基本步骤</h1><ol><li><code>npm i element-plus</code> </li><li>引入<br><code>import ElementPlus from &#39;element-plus&#39;</code><br><code>import &#39;element-plus/dist/index.css&#39;</code><br><code>app.use(ElementPlus)</code></li></ol><h1 id="使用icon图标"><a href="#使用icon图标" class="headerlink" title="使用icon图标"></a>使用icon图标</h1><p>1<code> npm install @element-plus/icons-vue</code><br>2.引入图标</p><h1 id="使用axios，二次封装"><a href="#使用axios，二次封装" class="headerlink" title="使用axios，二次封装"></a>使用axios，二次封装</h1><p>1.npm i axios<br>2.在src&#x2F;创建utils&#x2F;requests.ts<br>3.引入axios<br>利用axios.create创建一个axios实例，可以设置基础路径，超时时间的设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const requests = axios.create(&#123;</span><br><span class="line">  baseURL: &#x27;/api&#x27;,//请求的基础路径设置</span><br><span class="line">  timeout: 5000//超时时间的设置</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>添加请求拦截器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">requests.interceptors.request.use((config) =&gt; &#123;</span><br><span class="line">  //config:请求拦截器回调注入的对象（配置对象），配置对象的身上最重要的headers属性</span><br><span class="line">  //可以通过请求头携带公共参数token</span><br><span class="line">  return config;//必须要返回</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>响应拦截器，有两个回调函数<br>return 的数据会注入到发请求时的.then的参数中<br>response是一个数组,包括config,data，请求报文的信息等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">requests.interceptors.response.use((response) =&gt; &#123;</span><br><span class="line">  //响应拦截器成功的回调,一般会用来简化数据</span><br><span class="line">  return response.data;</span><br><span class="line">&#125;, (error) =&gt; &#123;</span><br><span class="line">  //请求失败的回调</span><br><span class="line">  //处理失败的回调，处理http返回的错误</span><br><span class="line">  let status = error.response.status</span><br><span class="line">  switch (status) &#123;</span><br><span class="line">    case 404:</span><br><span class="line">      ElMessage(&#123;</span><br><span class="line">        type: &#x27;error&#x27;,</span><br><span class="line">        message: error.message</span><br><span class="line">      &#125;)</span><br><span class="line">      break;</span><br><span class="line">    case 500 | 501 | 502 | 503 | 504 | 505:</span><br><span class="line">      ElMessage(&#123;</span><br><span class="line">        type: &#x27;error&#x27;,</span><br><span class="line">        message: &#x27;服务器挂了&#x27;</span><br><span class="line">      &#125;)</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  return Promise.reject(new Error(error.message))</span><br><span class="line">&#125;)</span><br><span class="line">//务必对外暴露</span><br><span class="line">export default requests;</span><br></pre></td></tr></table></figure><p>3.对于axios进行二次封装，目的？&#96;<br>  1利用axios请求，响应拦截器  2请求拦截器：在请求头中携带公共参数 3相应拦截器：简化服务器返回的数据，处理http网络错误</p><h1 id="动态追加或取消类名"><a href="#动态追加或取消类名" class="headerlink" title="动态追加或取消类名"></a>动态追加或取消类名</h1><p><code>&lt;li :class=&quot;&#123;active: isActive&#125;&quot;&gt;全部&lt;/li&gt;</code><br>在这个例子中，isActive 是一个布尔值。如果 isActive 为 true，则 <li> 元素会被添加 active 类；如果为 false，则不会添加。</li></p><h1 id="Pinia持久化插件"><a href="#Pinia持久化插件" class="headerlink" title="Pinia持久化插件"></a>Pinia持久化插件</h1><p>1.<code>npm i pinia-plugin-persistedstate</code><br>2.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createPinia &#125; from &#x27;pinia&#x27;</span><br><span class="line">import piniaPluginPersistedstate from &#x27;pinia-plugin-persistedstate&#x27;</span><br><span class="line">const pinia = createPinia()</span><br><span class="line">pinia.use(piniaPluginPersistedstate)</span><br></pre></td></tr></table></figure><p>3.记得在仓库的定义文件中添加 <code>persist: true</code></p><h1 id="文字要溢出时添加滚动效果，点击某个元素使其对应的内容滚动到最上方"><a href="#文字要溢出时添加滚动效果，点击某个元素使其对应的内容滚动到最上方" class="headerlink" title="文字要溢出时添加滚动效果，点击某个元素使其对应的内容滚动到最上方"></a>文字要溢出时添加滚动效果，点击某个元素使其对应的内容滚动到最上方</h1><p><code>overflow:scroll</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">element.scrollIntoView(&#123;</span><br><span class="line">  block: &#x27;start&#x27;,</span><br><span class="line">  behavior:&#x27;smooth&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id><a href="#" class="headerlink" title></a></h1><p>需要使用深度选择器<br>原生css选择器 &gt;&gt;&gt;<br>less中&#x2F;deep&#x2F;<br>sass中::v-deep</p><h1 id="使用微信扫码登录"><a href="#使用微信扫码登录" class="headerlink" title="使用微信扫码登录"></a>使用微信扫码登录</h1><p>1.在index.html中引入<code>&lt;script src=&quot;https://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js&quot;&gt;&lt;/script&gt;</code><br>2.在相应组件中创建实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new WxLogin(&#123;</span><br><span class="line">  self_redirect: true,  // true：手机点击确认登录后可以在iframe内跳转到redirect_uri</span><br><span class="line">  id: &quot;login_container&quot;,  // 显示二维码容器的id</span><br><span class="line">  appid: result.data.appid,  // 应用位置标识appid（请替换为您的appid）</span><br><span class="line">  scope: &quot;snsapi_login&quot;,  // 当前微信扫码登录页面已经授权了</span><br><span class="line">  redirect_uri: result.data.redirectUri,  // 填写授权回调域路径（请替换为您的回调地址）</span><br><span class="line">  state: result.data.state,  // state就是学校服务器重定向的地址携带用户信息（可根据需要设置）</span><br><span class="line">  style: &quot;black&quot;,  // 二维码样式</span><br><span class="line">  href:&#x27;&#x27;</span><br><span class="line">  // 注意：href参数在WxLogin构造函数中通常不是必需的，因为它与扫码登录流程无直接关系</span><br><span class="line">  // 如果您需要在扫码成功后进行某些操作，请在redirect_uri中处理</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="nprogress进度条插件"><a href="#nprogress进度条插件" class="headerlink" title="nprogress进度条插件"></a>nprogress进度条插件</h1><ol><li><code>npm i nprogress</code></li><li>通常在路由鉴权permission.ts文件中引入，<code>import Nprogress from &#39;nprogress&#39;</code>,<code>import &quot;../node_modules/nprogress/nprogress.css&quot;</code><strong>一定要引入样式</strong>，否则不显示。</li><li>进度条的加载小圆球不要 Nprogress.configure({ showSpinner: false })</li><li>进度条开始<code> Nprogress.start()</code>，进度条结束<code> Nprogress.done()</code></li></ol><h1 id="当在路由守卫中使用pinia时"><a href="#当在路由守卫中使用pinia时" class="headerlink" title="当在路由守卫中使用pinia时"></a>当在路由守卫中使用pinia时</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ❌ 由于引入顺序的问题，这将失败</span><br><span class="line">const store = useStore()</span><br><span class="line"></span><br><span class="line">router.beforeEach((to) =&gt; &#123;</span><br><span class="line">  // ✅ 这样做是可行的，因为路由器是在其被安装之后开始导航的，</span><br><span class="line">  // 而此时 Pinia 也已经被安装。</span><br><span class="line">  const store = useStore()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="npm-run-build项目打包时遇到的问题"><a href="#npm-run-build项目打包时遇到的问题" class="headerlink" title="npm run build项目打包时遇到的问题"></a>npm run build项目打包时遇到的问题</h1><ul><li>‘rules’ is declared but its value is never read<br>在package.json中修改命令”build”: “vite build”<br><img src="/2024/11/10/guigu/image%20copy.png" alt="alt text"></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Element 组件库</title>
      <link href="/2024/11/10/Element-el-row-el-col%E5%B8%83%E5%B1%80/"/>
      <url>/2024/11/10/Element-el-row-el-col%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="el布局"><a href="#el布局" class="headerlink" title="el布局"></a>el布局</h1><p>element的布局方式与bootstrap原理是一样的，将网页划分成若干行，然后每行等分为若干列，基于这样的方式进行布局，形象的成为栅栏布局。<br>区别是element可将每行划分为24个分栏，而bootstrap是划分为12个分栏，从使用角度，还是24个分栏更加精细。</p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>首先每行使用<code>&lt;el-row&gt;</code>标签标识，然后每行内的列使用<code>&lt;el-col&gt;</code>标识，至于每列整行的宽度比例，则使用:span属性进行设置。</p><h3 id="分栏间隔"><a href="#分栏间隔" class="headerlink" title="分栏间隔"></a>分栏间隔</h3><p>有时候想为不同分栏之间设定一定的间隔，可以使用<code>&lt;el-row&gt;</code>标签的:gutter属性，注意默认间隔为0。<br>以下写法不生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;分栏间隔 无效&lt;/span&gt;</span><br><span class="line">&lt;el-row :gutter=&quot;50&quot;&gt;</span><br><span class="line">  &lt;el-col :span=&quot;8&quot; class=&quot;lightgreen-box&quot;&gt;示例2&lt;/el-col&gt;</span><br><span class="line">  &lt;el-col :span=&quot;8&quot; class=&quot;orange-box&quot;&gt;示例2&lt;/el-col&gt;</span><br><span class="line">  &lt;el-col :span=&quot;8&quot; class=&quot;lightgreen-box&quot;&gt;示例2&lt;/el-col&gt;</span><br><span class="line">&lt;/el-row&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;分栏间隔 有效&lt;/span&gt;</span><br><span class="line">    &lt;el-row :gutter=&quot;24&quot;&gt;</span><br><span class="line">      &lt;el-col :span=&quot;8&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;lightgreen-box&quot;&gt;示例3&lt;/div&gt;</span><br><span class="line">      &lt;/el-col&gt;</span><br><span class="line">      &lt;el-col :span=&quot;8&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;orange-box&quot;&gt;示例3&lt;/div&gt;</span><br><span class="line">      &lt;/el-col&gt;</span><br><span class="line">      &lt;el-col :span=&quot;8&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;lightgreen-box&quot;&gt;示例3&lt;/div&gt;</span><br><span class="line">      &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br></pre></td></tr></table></figure><h3 id="分栏偏移"><a href="#分栏偏移" class="headerlink" title="分栏偏移"></a>分栏偏移</h3><p>有时候想让某个分栏不从左边显示，而是直接显示到中间或者右侧，例如右侧导航栏，我们希望它处于右侧且占据页面1&#x2F;3的宽度。此时可以借助offset属性来实现，表示偏移量。<br>此时，想占据1&#x2F;3宽度，则:span应为8，偏移量应为24-8&#x3D;16，所以代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;分栏偏移&lt;/span&gt;</span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">      &lt;el-col :span=&quot;8&quot; :offset=&quot;16&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;lightgreen-box&quot;&gt;示例4&lt;/div&gt;</span><br><span class="line">      &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line">    &lt;el-divider&gt;&lt;/el-divider&gt;//分割线</span><br></pre></td></tr></table></figure><p>更具体的用法<br><a href="https://element-plus.org/zh-CN/component/layout.html">https://element-plus.org/zh-CN/component/layout.html</a></p><h1 id="表单的校验"><a href="#表单的校验" class="headerlink" title="表单的校验"></a>表单的校验</h1><p>inline属性可以让表单元素在一行上显示</p><h2 id="大致使用步骤"><a href="#大致使用步骤" class="headerlink" title="大致使用步骤"></a>大致使用步骤</h2><p>1.双向绑定表单收集的数据，校验规则<code>&lt;el-form class=&quot;form&quot; :rules=&quot;rules&quot; :model=&quot;loginForm&quot;&gt;</code><br>:model&#x3D;”loginForm”是收集表单数据，ref&#x3D;”login”是获取表单元素，利用form上的validate()方法，反映校验是否成功<br>2.给<strong>表单元素</strong>加prop属性<code> &lt;el-form-item prop=&quot;username&quot;&gt;</code>,声明需要校验的数据<br>3.在<code>&lt;script&gt;</code>中定义校验规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const rules = reactive(&#123;</span><br><span class="line">  username: [</span><br><span class="line">    &#123; required: true, message: &#x27;请输入用户名&#x27;, trigger: &#x27;blur&#x27; &#125;,</span><br><span class="line">     &#123; min: 3, max: 5, message: &#x27;用户名长度应为3~5个字符&#x27;, trigger: &#x27;blur&#x27; &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>required:代表这个字段务必要校验<br>message:错误提示信息<br>trigger:触发表单校验时机，change-&gt;文本发生变化时触发校验，blur-&gt;失去焦点时触发<br><code>loginForms.value.validate()</code>返回一个promise对象，表示校验是否成功（符合写的rules而不是用户名密码是否正确）<br>清除掉对应图片校验结果：loginForm.value.clearValidate(‘logoUrl’)<br>resetFields重置该表单项，将其值重置为初始值，并移除校验结果<br>clearValidate清理某个字段的表单验证信息。</p><h2 id="自定义表单校验"><a href="#自定义表单校验" class="headerlink" title="自定义表单校验"></a>自定义表单校验</h2><p>rule:即为校验规则对象<br>value:即为表单元素文本内容<br>callback：函数如果符合条件callback放行通过<br>如果不符合条件，callback方法注入错误提示信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const validatorUserName = (rule:any,value:any,callback: any)=&gt;&#123;</span><br><span class="line">  if(value.length&gt;=5)&#123;//必须全是数字</span><br><span class="line">    callback()</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    callback(new Error(&#x27;账号长度至少五位&#x27;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const rules = reactive(&#123;</span><br><span class="line">  username: [</span><br><span class="line">    &#123;validator:validatorUserName, trigger: &#x27;change&#x27; &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>*** prop的属性名应该在表单:model&#x3D;”form”中存在 ***<br>详情见：<a href="https://element-plus.org/zh-CN/component/form.html">https://element-plus.org/zh-CN/component/form.html</a></p><h1 id="表格的使用"><a href="#表格的使用" class="headerlink" title="表格的使用"></a>表格的使用</h1><p><a href="https://element-plus.org/zh-CN/component/table.html#table-%E8%A1%A8%E6%A0%BC">https://element-plus.org/zh-CN/component/table.html#table-%E8%A1%A8%E6%A0%BC</a><br>表格组件：用于展示已有得平台数据<br>table:—border:可以设置表格纵向是否有边框<br>:data绑定的数据 对象数组<br>table-column:<br>·width:设置这列宽度<br>·align:设置内容居中对齐<br>·label:列名<br>·prop:内容<strong>注意</strong>这里直接写属性名即可，不用写 abc.属性名<br>· show-overflow-tooltip：某行文字过长隐藏<br>·fixed: true（固定在左侧）  false(固定在右侧)<br>·toggleRowSelection(row,true)：注意<strong>父组件是table</strong>用于多选表格，切换某一行的选中状态， 如果使用了第二个参数，则可直接设置这一行选中与否<br>·插槽：这里的<code>&lt;template&gt;</code>标签配合 #default 插槽名称，定义了这一列的默认内容渲染方式.{ row, $index }是 Element UI 传递给插槽的作用域变量。row 代表当前行的数据对象，而 $index 代表当前行的索引（从 0 开始）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template #default=&quot;&#123; row, $index &#125;&quot;&gt;</span><br><span class="line">  &lt;img :src=&quot;row.logoUrl&quot; alt=&quot;&quot; style=&quot;width: 100px; height: 100px;&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h1 id="Pagination-分页"><a href="#Pagination-分页" class="headerlink" title="Pagination 分页"></a>Pagination 分页</h1><p><a href="https://element-plus.org/zh-CN/component/pagination.html#pagination-%E5%88%86%E9%A1%B5">https://element-plus.org/zh-CN/component/pagination.html#pagination-%E5%88%86%E9%A1%B5</a><br>分页器不显示，检查后端返回的数据total<br>关于currentPage和pageSize的数据变化我们不需要担心因为分页器用v-model帮我们收集好了</p><h1 id="对话框dialog"><a href="#对话框dialog" class="headerlink" title="对话框dialog"></a>对话框dialog</h1><h1 id="upload上传"><a href="#upload上传" class="headerlink" title="upload上传"></a>upload上传</h1><p><a href="https://element-plus.org/zh-CN/component/upload.html#upload-%E4%B8%8A%E4%BC%A0">https://element-plus.org/zh-CN/component/upload.html#upload-%E4%B8%8A%E4%BC%A0</a><br>action 请求路径</p><h1 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h1><p>当用户从下拉菜单中选择一个选项时，<code>&lt;el-select&gt;</code> 的 v-model 绑定的值会自动更新为被选中 <code>&lt;el-option&gt;</code>的 value 值。<br>label选项的标签，若不设置则默认与value相同<br>@change事件：选中值发生变化时触发</p><h1 id="照片墙"><a href="#照片墙" class="headerlink" title="照片墙"></a>照片墙</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-upload</span><br><span class="line">  v-model:file-list=&quot;Images&quot;</span><br><span class="line">  action=&quot;/api/admin/product/fileUpload&quot;</span><br><span class="line">  list-type=&quot;picture-card&quot;</span><br><span class="line">  :on-preview=&quot;handlePictureCardPreview&quot;</span><br><span class="line">  :on-remove=&quot;handleRemove&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;el-icon&gt;&lt;Plus /&gt;&lt;/el-icon&gt;</span><br><span class="line">&lt;/el-upload&gt;</span><br><span class="line">&lt;el-dialog v-model=&quot;dialogVisible&quot;&gt;</span><br><span class="line">  &lt;img w-full :src=&quot;dialogImageUrl&quot; alt=&quot;Preview Image&quot; /&gt;</span><br><span class="line">&lt;/el-dialog&gt;</span><br></pre></td></tr></table></figure><p><code>v-model:file-list=&quot;Images&quot;</code>：父子组件数据同步<br>action：发送请求的URL用来上传图片<br>获取图片时，组件定义的是name和url;注意自己定义的数据是否有这两个字段名，如果没有，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Images.value=result1.data.map(item=&gt;&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    name: item.imgName,</span><br><span class="line">    url: item.imgUrl</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>遍历result1.data数组，对于数组中的每个元素（每个元素都是一个包含图片信息的对象），提取出每个元素的imgName和imgUrl属性，并将这些属性封装成一个新的对象。最终，所有这些新对象组成一个新的数组，这个数组被赋值给Images.value。<br>并修改ts类型。<br><code>:on-preview</code>:点击文件列表中已上传的文件时的钩子（预览）这里绑定事件显示对话框。<br><code>:on-remove</code>：删除文件之前的钩子，参数为上传的文件和文件列表， 若返回 false 或者返回 Promise 且被 reject，则停止删除。<br><code>before-upload</code>:上传文件之前的钩子，参数为上传的文件， 若返回false或者返回 Promise 且被 reject，则停止上传。</p><h1 id="根据输入列举相关信息"><a href="#根据输入列举相关信息" class="headerlink" title="根据输入列举相关信息"></a>根据输入列举相关信息</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-autocomplete</span><br><span class="line">  v-model=&quot;hosname&quot;</span><br><span class="line">  :fetch-suggestions=&quot;querySearch&quot;</span><br><span class="line">  @select=&quot;handleSelect&quot;</span><br><span class="line">  :trigger-on-focus=&quot;false&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;/el-autocomplete&gt;</span><br></pre></td></tr></table></figure><p>触发选中建议事件,这里的item的值是querySearch中cb函数所传递的数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const handleSelect=(item:any)=&gt;&#123;</span><br><span class="line">  // console.log(item)</span><br><span class="line">  router.push(&#x27;/hospital&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当input框发生变化时触发（默认聚焦时就会触发），<br>:trigger-on-focus&#x3D;”false”（当input中有数据才会触发）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const querySearch=async(value:string,cb:any)=&gt;&#123;</span><br><span class="line">  let result = await reqHospitalName(value)</span><br><span class="line">    let arr=result.data.map((item:any)=&gt;&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        value:item.hosname,</span><br><span class="line">        hoscode:item.hoscode</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    cb(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cb函数将获取到的参数展示到详情框中，注意这里被展示的数据的key一定是value</p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-descriptions title=&quot;挂号信息&quot; :column=&quot;3&quot; border&gt;</span><br><span class="line">    &lt;el-descriptions-item&gt;</span><br><span class="line">      &lt;template #label&gt;</span><br><span class="line">        &lt;div class=&quot;cell-item&quot;&gt;</span><br><span class="line">         就诊日期：</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">     内容</span><br><span class="line">    &lt;/el-descriptions-item&gt;</span><br><span class="line">  &lt;/el-descriptions&gt;</span><br></pre></td></tr></table></figure><p>:column&#x3D;”3”指每一行有三列</p><h1 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-menu :default-active=&quot;`$&#123;$route.path&#125;`&quot;  class=&quot;el-menu-vertical-demo&quot;&gt;</span><br><span class="line">    &lt;el-menu-item index=&quot;/user/real&quot; @click=&quot;gonext(&#x27;/user/real&#x27;)&quot;&gt;</span><br><span class="line">      &lt;el-icon&gt;&lt;Postcard /&gt;&lt;/el-icon&gt;</span><br><span class="line">      &lt;span&gt;实名认证&lt;/span&gt;</span><br><span class="line">    &lt;/el-menu-item&gt;</span><br><span class="line">  &lt;/el-menu&gt;</span><br></pre></td></tr></table></figure><p><code>:default-active=&quot;</code>${$route.path}<code>&quot; </code>默认高亮为此时的路由</p><h1 id="级联选择器"><a href="#级联选择器" class="headerlink" title="级联选择器"></a>级联选择器</h1><p><code> &lt;el-cascader :props=&quot;props&quot;/&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const props: CascaderProps = &#123;</span><br><span class="line">  lazy: true,//懒加载数据</span><br><span class="line">  async lazyLoad(node, resolve) &#123;</span><br><span class="line">   let result = await reqAllCities(node.data.id||&#x27;86&#x27;)</span><br><span class="line">   let showData = result.data.map((item:any)=&gt;&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      id:item.id,</span><br><span class="line">      label:item.name,</span><br><span class="line">      value:item.value,</span><br><span class="line">      leaf:!item.hasChildren</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    //注入组件需要展示的数据</span><br><span class="line">    resolve(showData)</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leaf:还有没有子节点<br>label：展示数据的名字<br>value：收集某个数据的值<br>node:你选择的节点的信息<br>最开始的时候会执行一次，后面每选择一次，也会执行一次</p>]]></content>
      
      
      
        <tags>
            
            <tag> Element组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript</title>
      <link href="/2024/11/07/TypeScript/"/>
      <url>/2024/11/07/TypeScript/</url>
      
        <content type="html"><![CDATA[<h2 id="编译TypeScript"><a href="#编译TypeScript" class="headerlink" title="编译TypeScript"></a>编译TypeScript</h2><h3 id="命令行编译"><a href="#命令行编译" class="headerlink" title="命令行编译"></a>命令行编译</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tesc index</span><br></pre></td></tr></table></figure><h3 id="自动化编译"><a href="#自动化编译" class="headerlink" title="自动化编译"></a>自动化编译</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tesc init</span><br><span class="line">tesc --watch (监视所有文件)</span><br></pre></td></tr></table></figure><h3 id="tsconfig-json文件"><a href="#tsconfig-json文件" class="headerlink" title="tsconfig.json文件"></a>tsconfig.json文件</h3><p>当出现错误时，不进行转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;noEmitOnError&quot;: true,   </span><br></pre></td></tr></table></figure><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p><a href="./TypeScript/1.png"></a><a href="./TypeScript/2.png"></a></p><h3 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let a: string</span><br><span class="line">let b: number</span><br><span class="line">let c: boolean</span><br><span class="line">let d: &#x27;hello&#x27; //字面量类型以后只能存hello</span><br><span class="line">function count(x: number, y: number): number &#123;</span><br><span class="line">  return x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:string 和 String 不一样，后者是包装对象<br><a href="./TypeScript/3.png"></a><br><a href="./TypeScript/4.png"></a></p><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>任意类型，不进行类型检查</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a: any</span><br><span class="line">//或let a </span><br><span class="line">a = 99</span><br><span class="line">a =&#x27;swjnswj&#x27;</span><br><span class="line">a =true</span><br></pre></td></tr></table></figure><p>any类型的变量可以赋值给任意类型的变量</p><h3 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h3><p>这样写是不行的即使此时s的值是个字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let s:unknown</span><br><span class="line">s=2</span><br><span class="line">s=true</span><br><span class="line">s = &#x27;as&#x27;</span><br><span class="line">let x: string</span><br><span class="line">x=s</span><br></pre></td></tr></table></figure><p>方法一</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(typeof s === &#x27;string&#x27;)&#123;</span><br><span class="line">  x=s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：断言的两种形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = s as string </span><br><span class="line">x = &lt;string&gt;s</span><br></pre></td></tr></table></figure><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p>通常对函数做限制,不能用于变量（没意义）<br>js中如果不写返回值则返回undefined</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function demo():never&#123;</span><br><span class="line">  demo()</span><br><span class="line">  throw new Error(&#x27;程序运行异常！&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>通常用于限制函数返回值<br><a href="./TypeScript/5.png"></a><a href="./TypeScript/6.png"></a></p><h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p><a href="./TypeScript/7.png"></a><a href="./TypeScript/8.png"></a></p><h3 id="声明一个对象类型"><a href="#声明一个对象类型" class="headerlink" title="声明一个对象类型"></a>声明一个对象类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let person: &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age?:number</span><br><span class="line">  [key:string]:any//索引签名</span><br><span class="line">&#125;</span><br><span class="line">person = &#123;name:&#x27;wyh&#x27;,age: 18&#125;</span><br><span class="line">person = &#123;name:&#x27;cyj&#x27;&#125;</span><br><span class="line">person = &#123;name:&#x27;cyj&#x27;;place:&#x27;河南&#x27;&#125;</span><br></pre></td></tr></table></figure><h3 id="声明一个函数类型"><a href="#声明一个函数类型" class="headerlink" title="声明一个函数类型"></a>声明一个函数类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let count: (a: number, b: number) =&gt; number</span><br><span class="line">count = (x,y) =&gt;&#123;</span><br><span class="line">  return x+y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明一个数组类型"><a href="#声明一个数组类型" class="headerlink" title="声明一个数组类型"></a>声明一个数组类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr: string[]</span><br><span class="line">let arr2: Array&lt;number&gt;</span><br><span class="line">arr =[&#x27;1&#x27;,&#x27;s&#x27;]</span><br><span class="line">arr2 =[100,200]</span><br></pre></td></tr></table></figure><h2 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组 tuple"></a>元组 tuple</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr1: [string,number]</span><br><span class="line">let arr2: [string,boolean?]</span><br><span class="line">let arr3: [number,...string[]]</span><br><span class="line"></span><br><span class="line">arr1 = [&#x27;hello&#x27;,12]</span><br><span class="line">arr2 = [&#x27;hello&#x27;,false]</span><br><span class="line">arr3 = [1,&#x27;a&#x27;]</span><br></pre></td></tr></table></figure><h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><p>可以定义一组命名常量,数字递增，反向映射，枚举中的属性是只读的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  up,</span><br><span class="line">  down,</span><br><span class="line">  left,</span><br><span class="line">  right</span><br><span class="line">&#125;</span><br><span class="line">console.log(Direction.down)</span><br><span class="line">console.log(Direction[0])</span><br></pre></td></tr></table></figure><p>字符串枚举没有反向映射</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  up=&quot;up&quot;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量枚举，js中代码量减少</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const enum Direction &#123;</span><br><span class="line">  up,</span><br><span class="line">  down,</span><br><span class="line">  left,</span><br><span class="line">  right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="type-联合类型"><a href="#type-联合类型" class="headerlink" title="type 联合类型"></a>type 联合类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Status = number | string</span><br><span class="line">type Gender = &#x27;男&#x27; | &#x27;女&#x27;</span><br><span class="line">function print(data:Status):void&#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;</span><br><span class="line">print(404)</span><br><span class="line">print(&#x27;404&#x27;)</span><br></pre></td></tr></table></figure><h2 id="type-并且类型"><a href="#type-并且类型" class="headerlink" title="type 并且类型"></a>type 并且类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type Area = &#123;</span><br><span class="line">  height: number;</span><br><span class="line">  width: number;</span><br><span class="line">&#125;</span><br><span class="line">type Address = &#123;</span><br><span class="line">  num:number;</span><br><span class="line">  cell:number</span><br><span class="line">&#125;</span><br><span class="line">type House = Area &amp; Address</span><br><span class="line">const house:House = &#123;</span><br><span class="line">  height: 122,</span><br><span class="line">  width: 222,</span><br><span class="line">  num: 23,</span><br><span class="line">  cell: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特殊情况void-不奏效"><a href="#特殊情况void-不奏效" class="headerlink" title="特殊情况void 不奏效"></a>特殊情况void 不奏效</h2><p><a href="./TypeScript/9.png"></a></p><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>public: 类内部，子类，类外部可以访问<br>protected:类内部，子类可以访问<br>private: 私有的，只有类内部可以访问<br>readonly: 只读属性</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>**抽象类不能实例化，其意义是可以被继承，抽象类里可以有普通方法，也可以有抽象方法<br>类的基本定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  name: string</span><br><span class="line">  constructor(name:string)&#123;</span><br><span class="line">    this.name=name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p = new Person(&#x27;wyh&#x27;)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  constructor(public name: string) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">abstract class Package &#123;</span><br><span class="line">  //构造方法</span><br><span class="line">  constructor(public weight: number) &#123; &#125;</span><br><span class="line">  //抽象方法</span><br><span class="line">  abstract calculate(): number</span><br><span class="line">  //具体方法</span><br><span class="line">  printPackage() &#123;</span><br><span class="line">    console.log(`包裹重量为：$&#123;this.weight&#125;kg,运费为：$&#123;this.calculate()&#125;元`)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class StandardPackage extends Package &#123;</span><br><span class="line">  constructor(</span><br><span class="line">    weight: number,</span><br><span class="line">    public unitPrice: number</span><br><span class="line">  ) &#123; super(weight) &#125;</span><br><span class="line">  calculate(): number &#123;</span><br><span class="line">    return this.weight * this.unitPrice</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const s1 = new StandardPackage(10, 5)</span><br><span class="line">s1.printPackage()</span><br></pre></td></tr></table></figure><p>当你创建一个子类并继承自一个父类时，如果父类有一个构造函数，那么子类在构造自身实例时必须通过 super() 调用父类的构造函数。<br>注意：抽象类被继承后子类必须<br>1.实现所有抽象方法：<br>子类必须实现父类中的所有抽象方法。如果子类没有实现所有抽象方法，那么子类本身也将成为抽象类，不能被实例化。<br>2.构造函数调用：<br>在子类的构造函数中，必须使用 super() 调用父类的构造函数，以确保父类被正确初始化。这是继承机制的一个基本要求。<br>3.访问修饰符：<br>注意父类和子类中属性和方法的访问修饰符。例如，如果父类中的某个抽象方法是 public 的，那么子类在实现这个方法时也必须是 public 的，或者具有更高的访问权限（如 protected 或包内可见性，但通常不会降低权限）。<br>4.抽象类不能被实例化：<br>抽象类本身不能被实例化，只能通过其子类来创建对象。这是抽象类的一个基本特性。<br>5.<strong>子类必须提供具体的实现。</strong></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>描述对象的格式</p><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface PersonInterface&#123;</span><br><span class="line">  name:string</span><br><span class="line">  age:number</span><br><span class="line">  speak(n:number):void</span><br><span class="line">&#125;</span><br><span class="line">class Person implements PersonInterface&#123;</span><br><span class="line">  constructor(public name:string,public age:number)&#123;&#125;</span><br><span class="line">  speak(n: number): void &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义对象"><a href="#定义对象" class="headerlink" title="定义对象"></a>定义对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const user: PersonInterface = &#123;</span><br><span class="line">  name:&#x27;zs&#x27;,</span><br><span class="line">  age: 19,</span><br><span class="line">  speak(n)&#123;</span><br><span class="line">    console.log(n)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface CountInterface&#123;</span><br><span class="line">  (a:number,b:number):number</span><br><span class="line">&#125;</span><br><span class="line">const count: CountInterface=(x,y)=&gt;&#123;</span><br><span class="line">  return x+y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口可以继承"><a href="#接口可以继承" class="headerlink" title="接口可以继承"></a>接口可以继承</h3><h3 id="接口自动合并"><a href="#接口自动合并" class="headerlink" title="接口自动合并"></a>接口自动合并</h3><h2 id="interface与type"><a href="#interface与type" class="headerlink" title="interface与type"></a>interface与type</h2><p>interface定义对象和类，支持继承，合并<br>type:可以定义类型别名，联合类型，交叉类型，</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function logData&lt;T&gt;(data: T)&#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;</span><br><span class="line">logData&lt;number&gt;(100)</span><br><span class="line">logData&lt;string&gt;(&#x27;abd&#x27;)</span><br></pre></td></tr></table></figure><p>泛型接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface PersonInterface&lt;T&gt;&#123;</span><br><span class="line">  name:string,</span><br><span class="line">  age:number,</span><br><span class="line">  other: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型类</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="/2024/11/07/Vue/"/>
      <url>/2024/11/07/Vue/</url>
      
        <content type="html"><![CDATA[<h2 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;h3&gt;姓名：&#123;&#123;student.name&#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;h3&gt;年龄：&#123;&#123;student.age&#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;h3 v-if=&quot;student.sex&quot;&gt;性别：&#123;&#123;student.sex&#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;h3&gt;爱好：&lt;/h3&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(value,index) in student.hobby&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">      &#123;&#123;value&#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;h3&gt;朋友们：&lt;/h3&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(value,index) in student.friends&quot;&gt;</span><br><span class="line">      &#123;&#123;value.name&#125;&#125;--&#123;&#123;value.age&#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  const vm = new Vue(&#123;</span><br><span class="line">    el: &#x27;.container&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      student: &#123;</span><br><span class="line">        name: &#x27;tom&#x27;,</span><br><span class="line">        age: 18,</span><br><span class="line">        hobby: [&#x27;抽烟&#x27;, &#x27;喝酒&#x27;, &#x27;烫头&#x27;],</span><br><span class="line">        mysex: &#x27;false&#x27;,</span><br><span class="line">        friends: [</span><br><span class="line">          &#123; name: &#x27;wyh&#x27;, age: 18 &#125;,</span><br><span class="line">          &#123; name: &#x27;zsh&#x27;, age: 30 &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">  &#125;) </span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;student.age++&quot;&gt;年龄+1&lt;/button&gt;&lt;br&gt;</span><br><span class="line">&lt;button @click=&quot;addsex()&quot;&gt;添加性别属性，默认值：男&lt;/button&gt;&lt;br&gt;</span><br><span class="line">&lt;!-- &lt;button @click=&quot;student.sex=&#x27;位置&#x27;&quot;&gt;点击切换性别&lt;/button&gt;&lt;br&gt; --&gt;</span><br><span class="line">&lt;button @click=&quot;change()&quot;&gt;点击切换性别&lt;/button&gt;&lt;br&gt;</span><br><span class="line">&lt;button @click=&quot;addfriends()&quot;&gt;在列表首位添加一个朋友&lt;/button&gt;&lt;br&gt;</span><br><span class="line">&lt;button @click=&quot;student.friends[0].name=&#x27;张三&#x27;&quot;&gt;</span><br><span class="line">修改第一个朋友的名字为：张三</span><br><span class="line">&lt;/button&gt;&lt;br&gt;</span><br><span class="line">&lt;button @click=&quot;addhobby()&quot;&gt;添加一个爱好&lt;/button&gt;&lt;br&gt;</span><br><span class="line">&lt;button @click=&quot;changehobby()&quot;&gt;修改第一个爱好为开车&lt;/button&gt;&lt;br&gt;</span><br><span class="line">&lt;button @click=&quot;remove()&quot;&gt;点我移除抽烟&lt;/button&gt;</span><br></pre></td></tr></table></figure><p> 注意：student.friends[0].name这样修改是响应式的结果因为student.friends[0]看作一个对象，而name就是他的一个属性，name对应的有setter和getter<br>    而student.friends[0]&#x3D;{}，这样修改不是响应式的，因为student.friends[0]并没有对应的setter和getter<br>后面加的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  addsex() &#123;</span><br><span class="line">    // Vue.set(this.student, &#x27;sex&#x27;, &#x27;男&#x27;)</span><br><span class="line">    // vm.$set(this.student, &#x27;sex&#x27;, &#x27;男&#x27;)</span><br><span class="line">    this.$set(this.student, &#x27;sex&#x27;, &#x27;男&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  change() &#123;</span><br><span class="line">    this.student.mysex = !this.student.mysex</span><br><span class="line">    this.student.sex = this.student.mysex === true ? &#x27;女&#x27; : &#x27;男&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  addfriends() &#123;</span><br><span class="line">    this.student.friends.unshift(&#123; name: &#x27;jack&#x27;, age: 56 &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  addhobby() &#123;</span><br><span class="line">    this.student.hobby.push(&#x27;学习&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  changehobby() &#123;</span><br><span class="line">    // this.student.hobby.splice(0, 1, &#x27;开车&#x27;)</span><br><span class="line">    Vue.set(this.student.hobby, 0, &#x27;开车&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  remove() &#123;</span><br><span class="line">    this.student.hobby = this.student.hobby.filter((h) =&gt; &#123;</span><br><span class="line">      return h !== &#x27;抽烟&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>而且vue.set不能添加直接在data上的属性。总的来说就是如果改变的是对象的属性值或增加某一对象，就用this.$set；如果是数组上的增删改，就用提供的7个api<br>4.在Vue修改数组中的某个元素一定要用以下方法：push(),pop(),shift(),unshift(),splice(),sort(),reverse() &#x2F; Vue.set()或者vm.$set()<br>特别注意！Vue.set()或者vm.$set()不能给vm上或者vm.data上添加属性<br>3.如何监测数组中的数据？通过包裹数组更新元素的方法实现，本质是做了两件事：调用原生对应的方法对数组更新；重新解析模板进而更新页面。<br>1.vue会监视data中所有层次的数据<br>2.如何监测对象中的数据？通过setter实现监视，且要在new Vue时就传入要检测的数据<br>对象中后追加的属性，Vue默认不做响应式处理，如果要给后添加的属性做响应式，用<br>Vue.set(target,propertyName&#x2F;index,value)或Vm.$set(target,propertyName&#x2F;index,value)</p><p>Vue.delete</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><img src="/2024/11/07/Vue/image-2.png" alt="alt text"><br><img src="/2024/11/07/Vue/image-3.png" alt="alt text"><br><img src="/2024/11/07/Vue/image-4.png" alt="alt text"><br><img src="/2024/11/07/Vue/image.png" alt="alt text"></p><h3 id="多级路由"><a href="#多级路由" class="headerlink" title="多级路由"></a>多级路由</h3><p><img src="/2024/11/07/Vue/image-1.png" alt="alt text"><br>当使用children属性定义子路由时，子路由的path属性前不要带“&#x2F;”，否则会永远以根路径开始请求。子路由的路径是相对于父路由的路径的。</p><h3 id="query-参数"><a href="#query-参数" class="headerlink" title="query 参数"></a>query 参数</h3><p>query参数以键值对的形式出现在URL的问号之后</p><!-- 跳转路由并携带query参数。to 的字符串写法 --><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;router-link :to=&quot;`/home/message/detail?id=$&#123;m.id&#125;&amp;title=$&#123;m.title&#125;`&quot;&gt;</span><br><span class="line">  &#123;&#123; m.title &#125;&#125;</span><br><span class="line">&lt;/router-link&gt; --&gt;</span><br><span class="line">&lt;!-- 跳转路由并携带query参数。to 的对象写法 --&gt;</span><br><span class="line">&lt;router-link</span><br><span class="line">  :to=&quot;&#123;</span><br><span class="line">    path: &#x27;/home/message/detail&#x27;,</span><br><span class="line">    query: &#123;</span><br><span class="line">      id: m.id,</span><br><span class="line">      title: m.title,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &#123;&#123; m.title &#125;&#125;</span><br><span class="line">&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><h3 id="params参数"><a href="#params参数" class="headerlink" title="params参数"></a>params参数</h3><p>定义：params参数是路由中的一部分，在配置路由的时候需要占位。它通常用于指定路由的一部分，以标识特定资源。<br>使用方式：params参数通过URL路径的一部分传递，例如“&#x2F;users&#x2F;{id}”，其中“{id}”就是一个路径参数。在Vue等前端框架中，可以通过对象形式并指定name属性来传递params参数，如{ name: ‘search’, params: { keyword: this.keyword } }。</p><p>注意：<br>params参数只能通过name属性来引入路由，如果指定了path属性而没有name属性，界面能成功跳转但不能接收传递过来的参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;m in messagelist&quot; :key=&quot;m.id&quot;&gt;</span><br><span class="line">    &lt;!-- 跳转路由并携带params参数。to 的字符串写法 --&gt;</span><br><span class="line">    &lt;router-link :to=&quot;`/home/message/detail/$&#123;m.id&#125;/$&#123;m.title&#125;`&quot;&gt;</span><br><span class="line">      &#123;&#123; m.title &#125;&#125;</span><br><span class="line">    &lt;/router-link&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>注意要有占位符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: &#x27;xiaoxi&#x27;,</span><br><span class="line">  path: &#x27;message&#x27;,</span><br><span class="line">  component: MyMessage,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: &#x27;xiangqing&#x27;,</span><br><span class="line">      path: &#x27;detail/:id/:title&#x27;,</span><br><span class="line">      component: MeDetail,</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>params参数的展示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;&#123;&#123; $route.params.id &#125;&#125;&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;&#123;&#123; $route.params.title &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>router-link是Vue Router提供的用于导航的组件，它可以用来创建链接到不同路由的链接。<br>当用户点击router-link时，它会更新URL并触发路由切换，从而加载并显示新的路由组件。<br>router-view是一个占位符组件，用于在其中渲染匹配到的路由组件。它是Vue Router用于嵌套路由的关键部分。<br>前者相当于导航，指明要去的地址，而后者就是展示的地方</p><h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p><img src="/2024/11/07/Vue/image-5.png" alt="alt text"></p><h3 id="props传参三种写法"><a href="#props传参三种写法" class="headerlink" title="props传参三种写法"></a>props传参三种写法</h3><p>正常接收props参数<br><img src="/2024/11/07/Vue/image-6.png" alt="alt text"><br>第三种写法可以解构赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props(&#123;query&#125;)&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    id:query.id,</span><br><span class="line">    title:query.title</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="replace写法"><a href="#replace写法" class="headerlink" title="replace写法"></a>replace写法</h3><p>替换掉浏览记录的最上面一条<br><img src="/2024/11/07/Vue/image-8.png" alt="alt text"><br>可以直接简写为replace</p><h3 id="编程式路由"><a href="#编程式路由" class="headerlink" title="编程式路由"></a>编程式路由</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;pushShow(m)&quot;&gt;push查看&lt;/button&gt;</span><br><span class="line">&lt;button @click=&quot;replaceShow(m)&quot;&gt;repalce查看&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  pushShow(m) &#123;</span><br><span class="line">    this.$router.push(&#123;</span><br><span class="line">      path: &quot;/home/message/detail&quot;,</span><br><span class="line">      query: &#123;</span><br><span class="line">        id: m.id,</span><br><span class="line">        title: m.title,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  replaceShow(m) &#123;</span><br><span class="line">    this.$router.replace(&#123;</span><br><span class="line">      path: &quot;/home/message/detail&quot;,</span><br><span class="line">      query: &#123;</span><br><span class="line">        id: m.id,</span><br><span class="line">        title: m.title,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><img src="/2024/11/07/Vue/image-9.png" alt="alt text"><br>前进后退调用的都是this.$router的方法<br>go若传的参数为正则往前走相应的步数，若为负则后退相应的步数</p><p>绝对路径<br>如果你的路径以 &#x2F; 开头，那么它被视为一个绝对路径。这意味着它会从应用的根路由开始解析。<br>例如，router-link to&#x3D;”&#x2F;about” 会导航到应用的 &#x2F;about 路由。</p><p>相对路径：<br>如果你的路径不以 &#x2F; 开头，那么它被视为一个相对路径。这意味着它会相对于当前路由的路径进行解析。<br>例如，如果你当前在 &#x2F;user&#x2F;123 路由，那么 router-link to&#x3D;”edit” 会导航到 &#x2F;user&#x2F;123&#x2F;edit（假设你的路由配置支持这样的解析）。</p><h3 id="关于路径问题"><a href="#关于路径问题" class="headerlink" title="关于路径问题"></a>关于路径问题</h3><p><font color="red">二级路由最好写成绝对路径</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">path: &#x27;/acl&#x27;,</span><br><span class="line">component: () =&gt; import(&#x27;@/layout/index.vue&#x27;),</span><br><span class="line">name: &#x27;Acl&#x27;,</span><br><span class="line">meta: &#123;</span><br><span class="line">title: &#x27;权限管理&#x27;,</span><br><span class="line">icon: &#x27;Lock&#x27;,</span><br><span class="line">&#125;,</span><br><span class="line">redirect: &#x27;/acl/user&#x27;,</span><br><span class="line">children: [</span><br><span class="line">&#123;</span><br><span class="line">  path: &#x27;/acl/user&#x27;,</span><br><span class="line">  component: () =&gt; import(&#x27;@/api/acl/user/index.vue&#x27;),</span><br><span class="line">  name: &#x27;user&#x27;,</span><br><span class="line">  meta: &#123;</span><br><span class="line">    title: &#x27;用户管理&#x27;,</span><br><span class="line">    icon: &#x27;User&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  path: &#x27;role&#x27;,</span><br><span class="line">  component: () =&gt; import(&#x27;@/api/acl/role/index.vue&#x27;),</span><br><span class="line">  name: &#x27;Role&#x27;,</span><br><span class="line">  meta: &#123;</span><br><span class="line">    title: &#x27;角色管理&#x27;,</span><br><span class="line">    icon: &#x27;UserFilled&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们可以看到，两个子路由分别由绝对路径和相对路径规定路径。并且我们想让子路由展现在layout模块中，而不是重新开一个新的页面。但是，如果是第二种写法，当你的路径不是…&#x2F;acl的时候，比如此时在&#x2F;home的路由下，我们要跳转到role，这时，就会新开一个页面，而不是我们预期的在layout的某一模块中呈现。但当你先跳转到&#x2F;acl&#x2F;user，再点击role,此时就会是我们预期的那样，路径变为&#x2F;acl&#x2F;role,因为&#x2F;acl的组件是layout，所以role会在layout的<code>&lt;router-view&gt;&lt;/router-view&gt;</code>中展示。<font color="red"><strong>要特别注意！！！</strong></font></p><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>1.多个组件依赖于同一状态（数据）<br>2.来自不同组件的行为需要变更同一状态<br>说白了就是有一个数据放到Vuex中，一个项目里的其他所有组件都可以进行读取，修改<br><img src="/2024/11/07/Vue/image-10.png" alt="alt text"></p><h3 id="工作原理图："><a href="#工作原理图：" class="headerlink" title="工作原理图："></a>工作原理图：</h3><p><img src="/2024/11/07/Vue/image-11.png" alt="alt text"><br><img src="/2024/11/07/Vue/image-12.png" alt="alt text"><br><img src="/2024/11/07/Vue/image-14.png" alt="alt text"><br>state:存放数据<br>actions,mutations（大写）,state都是对象</p><h3 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h3><p>1.npm i vuex<br>2.引入，Vue.use(Vuex)，就可以用 store了<br>在src中创建一个store文件夹，index.js 进行创建store</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//该文件用于创建store</span><br><span class="line">//引入vue</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">//引入vuex</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line">//使用插件</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line">//准备actions 用于响应组件中的动作</span><br><span class="line">const actions = &#123;</span><br><span class="line">  jia(context, value) &#123;</span><br><span class="line">    //context:一个小型store,包含你可能会用到的方法</span><br><span class="line">    //value:要加的数</span><br><span class="line">    //console.log(context, value)</span><br><span class="line">    context.commit(&#x27;JIA&#x27;, value)</span><br><span class="line">  &#125;,</span><br><span class="line">  jian(context, value) &#123;</span><br><span class="line">    context.commit(&#x27;JIAN&#x27;, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//准备mutations-用于操作数据(state)</span><br><span class="line">const mutations = &#123;</span><br><span class="line">  JIA(state, value) &#123;</span><br><span class="line">    //相当于_data,</span><br><span class="line">    //console.log(state, value)</span><br><span class="line">    state.sum += value</span><br><span class="line">  &#125;,</span><br><span class="line">  JIAN(state, value) &#123;</span><br><span class="line">    state.sum -= value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//准备state-用于存储数据(state)</span><br><span class="line">const state = &#123;</span><br><span class="line">  sum: 0</span><br><span class="line">&#125;</span><br><span class="line">const getters = &#123;</span><br><span class="line">  bigSum(state) &#123;</span><br><span class="line">    return state.sum * 10</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  actions,</span><br><span class="line">  mutations,</span><br><span class="line">  state,</span><br><span class="line">  getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>引入store</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>脚手架会先把所有import执行完再执行其他语句 ，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line">//引入store</span><br><span class="line">import store from &#x27;./store/index&#x27;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在store中use(Vuex)</p><p>3.store<br>4.让所有的vc都能看见store</p><p>context参数，把一些逻辑写到action中。如果逻辑简单，可以直接在组件中调用commit<br><img src="/2024/11/07/Vue/image-16.png" alt="alt text"><br><img src="/2024/11/07/Vue/image-17.png" alt="alt text"></p><h3 id="gettters"><a href="#gettters" class="headerlink" title="gettters"></a>gettters</h3><p>使用场景：state中的数据需要加工并且该加工逻辑会被多次复用<br>state相当于data,getters 相当于computed</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const getters = &#123;</span><br><span class="line">  bigSum(state) &#123;</span><br><span class="line">    return state.sum * 10</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和计算属性一样，返回值决定自身的值。$store.getters.bigSum;</p><h3 id><a href="#" class="headerlink" title></a></h3><p>写起来很麻烦<br><img src="/2024/11/07/Vue/image-18.png" alt="alt text"><br>我们可以通过计算属性进行简写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">sum() &#123;</span><br><span class="line">  return this.$store.state.sum;</span><br><span class="line">&#125;,</span><br><span class="line">schoolname() &#123;</span><br><span class="line">  return this.$store.state.schoolname;</span><br><span class="line">&#125;,</span><br><span class="line">subject() &#123;</span><br><span class="line">  return this.$store.state.subject;</span><br><span class="line">&#125;,</span><br><span class="line">bigSum() &#123;</span><br><span class="line">  return this.$store.getters.bigSum;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还麻烦<br>注意，属性名都是字符串可以简写去掉引号，属性值不能简写<br>…对象就相当于把对象中的值依次取出<br>别忘了在组件中引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapGetters, mapState, mapMutations, mapActions &#125; from &quot;vuex&quot;;</span><br><span class="line">//对象写法</span><br><span class="line">// ...mapState(&#123;</span><br><span class="line">//   mysum: &quot;sum&quot;,</span><br><span class="line">//   schoolname: &quot;schoolname&quot;,</span><br><span class="line">//   subject: &quot;subject&quot;,</span><br><span class="line">// &#125;),</span><br><span class="line">//数组写法（当你计算属性的方法名和store.state的方法名相同时</span><br><span class="line">//...mapState([&quot;sum&quot;, &quot;schoolname&quot;, &quot;subject&quot;]),</span><br><span class="line">//对象写法</span><br><span class="line">// ...mapGetters(&#123;</span><br><span class="line">//   bigSum: &quot;bigSum&quot;,</span><br><span class="line">// &#125;),</span><br><span class="line">//数组写法</span><br><span class="line">// ...mapGetters([&quot;bigSum&quot;]),</span><br></pre></td></tr></table></figure><p>为了简写组件的方法<br><img src="/2024/11/07/Vue/image-19.png" alt="alt text"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">注意！调用increment时要传参数，否则不知道加的是几；默认传的参数是event</span><br><span class="line">methods: &#123;</span><br><span class="line">//借助mapMutations生成对应的方法，方法中会调用commit 去联系mutations(对象写法)</span><br><span class="line">...mapMutations(&#123; increment: &quot;JIA&quot;, decrement: &quot;JIAN&quot; &#125;),</span><br><span class="line">//数组的写法，别忘了改上面的函数名</span><br><span class="line">// ...mapMutations([&quot;JIA&quot;, &quot;JIAN&quot;]),</span><br><span class="line">//...mapActions(&#123; delay: &quot;delayjia&quot;, incrementodd: &quot;oddjia&quot; &#125;),</span><br><span class="line">...mapActions([&quot;delayjia&quot;, &quot;oddjia&quot;]),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>以上是从各组件的角度读取vuex中共享数据的代码，那么如何实现各组件之间的数据共享呢？其实只需要像读取本组件的数据一样直接读取即可</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">//求和相关的配置</span><br><span class="line">const countOptions = &#123;</span><br><span class="line">  namespaced: true,// ---------------------注意</span><br><span class="line">  actions: &#123;</span><br><span class="line">    jia(context, value) &#123;</span><br><span class="line">      context.commit(&#x27;JIA&#x27;, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    jian(context, value) &#123;</span><br><span class="line">      context.commit(&#x27;JIAN&#x27;, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    JIA(state, value) &#123;</span><br><span class="line">      state.sum += value</span><br><span class="line">    &#125;,</span><br><span class="line">    JIAN(state, value) &#123;</span><br><span class="line">      state.sum -= value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  state: &#123;</span><br><span class="line">    sum: 0,</span><br><span class="line">    schoolname: &#x27;尚硅谷&#x27;,</span><br><span class="line">    subject: &#x27;前端&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    bigSum(state) &#123;</span><br><span class="line">      return state.sum * 10</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">//人员管理相关的配置</span><br><span class="line">const personOptions = &#123;</span><br><span class="line">  namespaced: true,</span><br><span class="line">  state: &#123;</span><br><span class="line">    plist: [&#123; id: Date.now(), name: &quot;张三&quot; &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    addWang(context, value) &#123;</span><br><span class="line">      if (value.name.indexOf(&#x27;王&#x27;) === 0) &#123;</span><br><span class="line">        context.commit(&#x27;ADDWANG&#x27;, value)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        alert(&#x27;只能添加一个姓王的人&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    firstname(state) &#123;</span><br><span class="line">      return state.plist[0].name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    ADD(state, p) &#123;</span><br><span class="line">      state.plist.unshift(p)</span><br><span class="line">    &#125;,</span><br><span class="line">    ADDWANG(state, value) &#123;</span><br><span class="line">      state.plist.unshift(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    countAbout: countOptions,</span><br><span class="line">    personAbout: personOptions</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  //对象写法</span><br><span class="line">  ...mapState(&quot;countAbout&quot;, &#123;</span><br><span class="line">    sum: &quot;sum&quot;,</span><br><span class="line">    schoolname: &quot;schoolname&quot;,</span><br><span class="line">    subject: &quot;subject&quot;,</span><br><span class="line">  &#125;),</span><br><span class="line">  ...mapState(&quot;personAbout&quot;, &#123; plist: &quot;plist&quot; &#125;),</span><br><span class="line">  //对象写法</span><br><span class="line">  ...mapGetters(&quot;countAbout&quot;, &#123;</span><br><span class="line">    bigSum: &quot;bigSum&quot;,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    this.$store.dispatch(&quot;countAbout/jia&quot;, this.n);</span><br><span class="line">  &#125;,</span><br><span class="line">  delay() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      this.$store.dispatch(&quot;countAbout/jia&quot;, this.n);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;,</span><br><span class="line">  decrement() &#123;</span><br><span class="line">    this.$store.dispatch(&quot;countAbout/jian&quot;, this.n);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="props传参"><a href="#props传参" class="headerlink" title="props传参"></a>props传参</h2><p>父组件给子组件传参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &quot;StudentName&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &quot;我是一个学生&quot;,</span><br><span class="line">      myage: this.age,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  // props: [&quot;name&quot;, &quot;sex&quot;, &quot;age&quot;],</span><br><span class="line">  // 注意大小写</span><br><span class="line">  //</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true,</span><br><span class="line">//name和sex这两个prop都被设置了required: true，这意味着在使用这个组件时，父组件必须提供name和sex这两个属性。</span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 99,</span><br><span class="line">//默认值99,这意味着如果父组件没有提供age的值，子组件中的ageprop将自动被设置为99</span><br><span class="line">    &#125;,</span><br><span class="line">    sex: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- 父组件模板 -->  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComponent :some-prop=&quot;myFunction&quot; /&gt;</span><br></pre></td></tr></table></figure><p>myFunction 是父组件中定义的一个方法，它将被作为 some-prop（在子组件中对应为 someProp）传递给 ChildComponent 子组件。注意，这里使用的是 :some-prop（或 v-bind:some-prop），因为 some-prop 是一个 prop 的名称，而 myFunction 是一个 JavaScript 表达式的值，该表达式的结果（即函数本身）将被绑定到 some-prop 上。</p><p>也可以子组件给父组件，这时需要父组件给子组件传递一个函数，然后子组件把要传的参数通过该函数传递<br>父组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;StudentName :getStudentName=&quot;getStudentName&quot;&gt;&lt;/StudentName&gt;</span><br><span class="line">methods: &#123;</span><br><span class="line">  getStudentName(name) &#123;</span><br><span class="line">    console.log(name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;transStudentName&quot;&gt;点我获取学生姓名&lt;/button&gt;</span><br><span class="line">props: [&quot;getStudentName&quot;],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    transStudentName() &#123;</span><br><span class="line">      this.getStudentName(this.name);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>自定义事件用于组件</p><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//通过父组件给子组件绑定一个自定义事件实现：子给父传递数据 </span><br><span class="line">&lt;SchoolName v-on:atschool.once=&quot;getSchoolName&quot;&gt;&lt;/SchoolName&gt;</span><br><span class="line">&lt;SchoolName v-on:atschool=&quot;getSchoolName&quot;&gt;&lt;/SchoolName&gt;</span><br><span class="line">&lt;SchoolName @atschool=&quot;getSchoolName&quot;&gt;&lt;/SchoolName&gt;</span><br><span class="line">getSchoolName(name1) &#123;</span><br><span class="line">  console.log(&quot;被处罚&quot;, name1);</span><br><span class="line">&#125;,</span><br><span class="line">//除了name还可以接收多个参数</span><br><span class="line">getSchoolName(name1,...a) &#123;</span><br><span class="line">  console.log(&quot;被处罚&quot;, name1);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;transSchoolName&quot;&gt;点我获取学校名&lt;/button&gt;</span><br><span class="line">methods: &#123;</span><br><span class="line">  transSchoolName() &#123;</span><br><span class="line">    this.$emit(&quot;atschool&quot;, this.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">  //解绑自定义事件</span><br><span class="line">  // setTimeout(() =&gt; &#123;</span><br><span class="line">  //   this.$off(&quot;atschool&quot;);</span><br><span class="line">  // &#125;, 7000);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>可以异步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 通过父组件给子组件绑定一个自定义事件实现：子给父传递数据 ref--&gt;</span><br><span class="line">&lt;SchoolName ref=&quot;atschool&quot;&gt; &lt;/SchoolName&gt;</span><br><span class="line">mounted() &#123;</span><br><span class="line">//注意是页面被挂载</span><br><span class="line"> setTimeout(() =&gt; &#123;</span><br><span class="line">   this.$refs.atschool.$on(&quot;atschool&quot;, this.getSchoolName);</span><br><span class="line"> &#125;, 3000);</span><br><span class="line">// 只触发一次</span><br><span class="line">// this.$refs.atschool.$once(&quot;atschool&quot;, this.getSchoolName);</span><br><span class="line">this.$refs.atschool.$on(&quot;atschool&quot;, this.getSchoolName);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>注意！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//若将函数当作参数传递</span><br><span class="line">this.$refs.atschool.$on(&quot;atschool&quot;, function(name1)&#123;</span><br><span class="line">  console.log(&quot;被处罚&quot;, name1);</span><br><span class="line">  this.schoolname = name1;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里面的this 所指对象是： 谁触发的这个事件就是谁，在这里是学校组件触发所以指的是学校实例对象<br>但如果写成箭头函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//若将函数当作参数传递,this指的就是app</span><br><span class="line">this.$refs.atschool.$on(&quot;atschool&quot;, (name1)=&gt;&#123;</span><br><span class="line">  console.log(&quot;被处罚&quot;, name1);</span><br><span class="line">  this.schoolname = name1;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 给组件绑定一个原生dom事件加上.native,否则会被看成自定义事件--&gt;</span><br><span class="line">&lt;SchoolName ref=&quot;atschool&quot; @click.native=&quot;show&quot;&gt; &lt;/SchoolName&gt;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/2024/11/07/Vue/image-24.png" alt="alt text"></p><p><img src="/2024/11/07/Vue/image-25.png" alt="alt text"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>About Vue3</title>
      <link href="/2024/11/07/About-Vue3/"/>
      <url>/2024/11/07/About-Vue3/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="创建一个vue3的项目"><a href="#创建一个vue3的项目" class="headerlink" title="创建一个vue3的项目"></a>创建一个vue3的项目</h2><h3 id="用vite"><a href="#用vite" class="headerlink" title="用vite"></a>用vite</h3><p>1.npm init vite-app vue3_vite（项目名称）<br>2.进入vue3_vite文件夹，安装依赖npm i<br>3.启动项目 npm run dev</p><h3 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h3><p>1.vue create vue_test<br>2.cd ,npm run serve</p><p><img src="/2024/11/07/About-Vue3/image.png" alt="alt text"><br><img src="/2024/11/07/About-Vue3/image-1.png" alt="alt text"><br><img src="/2024/11/07/About-Vue3/image-2.png" alt="alt text"><br>如果用ref监测一个对象类型的数据，那么ref 会求助reactive 把数据转换为 proxy类型的，<br>用reactive的话，数据直接就是proxy对象，就不用.value</p><p><img src="/2024/11/07/About-Vue3/image-3.png" alt="alt text"><br>下面为vue3内部的响应式的配置，Vue3可以直接对数据进行增删改查<br><img src="/2024/11/07/About-Vue3/image-4.png" alt="alt text"><br>其中，target 指 person,propName指所改的属性值<br><img src="/2024/11/07/About-Vue3/image-5.png" alt="alt text"></p><h2 id="ref和reactive对比："><a href="#ref和reactive对比：" class="headerlink" title="ref和reactive对比："></a>ref和reactive对比：</h2><p><img src="/2024/11/07/About-Vue3/image-6.png" alt="alt text"><br>为什么reactive监视数组不能直接反映出变化？<br>数组方法：Vue 3的响应式系统能够检测到对数组元素的直接修改（如arr[index] &#x3D; newValue）以及通过push、pop、shift、unshift、splice和sort、reverse这些内置方法进行的修改。然而，如果你使用非响应式的方法（如直接改变数组长度arr.length &#x3D; newLength或通过非响应式API如Array.prototype.filter、map等创建新数组），Vue可能无法检测到这些变化。<br>深度响应性：虽然reactive可以创建深度响应的对象，但对于数组中的对象元素，只有这些对象的顶层属性是响应式的。如果对象内部有嵌套对象或数组，并且你修改了这些嵌套对象或数组的属性，Vue可能无法自动检测到这些变化，除非这些嵌套对象或数组也被转换成响应式的。</p><h3 id="vue2-props，插槽-补充"><a href="#vue2-props，插槽-补充" class="headerlink" title="vue2 props，插槽 补充"></a>vue2 props，插槽 补充</h3><p>如果用props传数据的话，并且接收的话，那么会在vc实例对象上出现，但是不接收的话，就会出现在$attrs上<br>如果没有接收插槽的话，页面只是不显示，但是确实已经出现在组件实例对象的vc身上的$slots中<br><img src="/2024/11/07/About-Vue3/image-9.png" alt="alt text"><br><img src="/2024/11/07/About-Vue3/image-7.png" alt="alt text"><br>外部给组件传参时，并且数据是响应式的<br><img src="/2024/11/07/About-Vue3/image-8.png" alt="alt text"></p><p><img src="/2024/11/07/About-Vue3/image-10.png" alt="alt text"></p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>计算属性（computed properties）的定义是通过一个函数来创建的，但这个函数返回一个对象，这个对象描述了计算属性的 getter 和可选的 setter。</p><h4 id="简写形式"><a href="#简写形式" class="headerlink" title="简写形式"></a>简写形式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;一个人的信息&lt;/h2&gt;</span><br><span class="line">  姓：&lt;input type=&quot;text&quot; v-model=&quot;person.firstname&quot;&gt;</span><br><span class="line">  名：&lt;input type=&quot;text&quot; v-model=&quot;person.lastname&quot;&gt;</span><br><span class="line">  全名：&lt;h4&gt;&#123;&#123;person.fullName&#125;&#125;&lt;/h4&gt;</span><br><span class="line">  全名：&lt;input type=&quot;text&quot; v-model=&quot;person.fullName&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;reactive&#125; from &#x27;vue&#x27;</span><br><span class="line">import &#123;computed&#125; from &#x27;vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  setup()&#123;</span><br><span class="line">    let person = reactive(&#123;</span><br><span class="line">      firstname: &#x27;张&#x27;,</span><br><span class="line">      lastname: &#x27;三&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">    let fullName = computed(</span><br><span class="line">      ()=&gt;&#123;</span><br><span class="line">        return person.firstname + &#x27;-&#x27; + person.lastname</span><br><span class="line">      &#125;</span><br><span class="line">    ) </span><br><span class="line">    return &#123;</span><br><span class="line">      person,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的计算属性只可读，不可更改，也就是说最后一个文本框里的值不可以输入或删除<br>还可以这样写，相当于直接给person追加了一个属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person.fullName = computed(</span><br><span class="line">()=&gt;&#123;</span><br><span class="line">  return person.firstname + &#x27;-&#x27; + person.lastname</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><h4 id="完整版"><a href="#完整版" class="headerlink" title="完整版"></a>完整版</h4><p>完整版中fullName不再是person中的属性，因此在组件中引用时不必再加上person.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let fullName=computed(&#123;</span><br><span class="line">get()&#123;</span><br><span class="line">  return person.firstname + &#x27;-&#x27; + person.lastname</span><br><span class="line">&#125;,</span><br><span class="line">set(value)&#123;</span><br><span class="line">  const nameArr = value.split(&#x27;-&#x27;)</span><br><span class="line">  person.firstname=nameArr[0]</span><br><span class="line">  person.lastname=nameArr[1]</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">return &#123;</span><br><span class="line">  person,</span><br><span class="line">  fullName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="watch监视"><a href="#watch监视" class="headerlink" title="watch监视"></a>watch监视</h2><p>watch写在setup()里面<br>基本代码<br>这里面注意两个容易出错的点：<br>1.函数直接定义即可<br>2.ref类型的数据需要加.value</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;button @click=&quot;sum++&quot;&gt;点我+1&lt;/button&gt;</span><br><span class="line">  &lt;hr&gt;</span><br><span class="line">  &lt;h2&gt;当前的信息为&#123;&#123; msg &#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;button @click=&quot;changemsg&quot;&gt;修改信息&lt;/button&gt;</span><br><span class="line">  &lt;hr&gt;</span><br><span class="line">  &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;h2&gt;薪资：&#123;&#123; person.salary &#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;button @click=&quot;changename&quot;&gt;修改姓名&lt;/button&gt;</span><br><span class="line">  &lt;button @click=&quot;person.age++&quot;&gt;增长年龄&lt;/button&gt;</span><br><span class="line">  &lt;button @click=&quot;person.salary++&quot;&gt;涨薪&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;reactive,watch,ref&#125; from &#x27;vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  setup()&#123;</span><br><span class="line">    let sum=ref(0)</span><br><span class="line">    let msg=ref(&#x27;你好&#x27;)</span><br><span class="line">    let person=reactive(&#123;</span><br><span class="line">      name:&#x27;张三&#x27;,</span><br><span class="line">      age:18,</span><br><span class="line">      salary:20</span><br><span class="line">    &#125;)</span><br><span class="line">    let changemsg =()=&gt;msg.value += &#x27;!&#x27;</span><br><span class="line">    let changename =()=&gt;person.name += &#x27;!&#x27;</span><br><span class="line">    return &#123;</span><br><span class="line">      sum,</span><br><span class="line">      msg,</span><br><span class="line">      changemsg,</span><br><span class="line">      changename,</span><br><span class="line">      person</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="1-监视ref-所定义的一个响应式数据"><a href="#1-监视ref-所定义的一个响应式数据" class="headerlink" title="1.监视ref 所定义的一个响应式数据"></a>1.监视ref 所定义的一个响应式数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(sum,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">  console.log(&#x27;sum变了&#x27;,newValue,oldValue)</span><br><span class="line">&#125;,&#123;immediate:true&#125;)</span><br></pre></td></tr></table></figure><p><img src="/2024/11/07/About-Vue3/image-11.png"></p><h4 id="2-监视ref-所定义的多个响应式数据"><a href="#2-监视ref-所定义的多个响应式数据" class="headerlink" title="2.监视ref 所定义的多个响应式数据"></a>2.监视ref 所定义的多个响应式数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch([sum,msg],(newValue,oldValue)=&gt;&#123;</span><br><span class="line">  console.log(&#x27;sum,msg变了&#x27;,newValue,oldValue)</span><br><span class="line">&#125;,&#123;immediate:true&#125;)</span><br></pre></td></tr></table></figure><p><img src="/2024/11/07/About-Vue3/image-12.png" alt="alt text"></p><h4 id="3-监视reactive-所定义的一个响应式数据的全部属性"><a href="#3-监视reactive-所定义的一个响应式数据的全部属性" class="headerlink" title="3.监视reactive 所定义的一个响应式数据的全部属性"></a>3.监视reactive 所定义的一个响应式数据的全部属性</h4><h5 id="注意1-此处无法正确的获取oldValue-2-强制开启了深度监视"><a href="#注意1-此处无法正确的获取oldValue-2-强制开启了深度监视" class="headerlink" title="注意1.此处无法正确的获取oldValue  2.强制开启了深度监视"></a>注意1.此处无法正确的获取oldValue  2.强制开启了深度监视</h5><p>就算person中还有一个对象，也会被监视到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(person,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">  console.log(&#x27;person变了&#x27;,newValue,oldValue)</span><br><span class="line">&#125;,&#123;deep:false&#125;)</span><br></pre></td></tr></table></figure><p><img src="/2024/11/07/About-Vue3/image-13.png" alt="alt text"></p><h4 id="4-监视reactive-所定义的一个响应式数据的某个属性—写成函数的形式"><a href="#4-监视reactive-所定义的一个响应式数据的某个属性—写成函数的形式" class="headerlink" title="4.监视reactive 所定义的一个响应式数据的某个属性—写成函数的形式"></a>4.监视reactive 所定义的一个响应式数据的某个属性—写成函数的形式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(()=&gt;person.age,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">  console.log(&#x27;person  age变了&#x27;,newValue,oldValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="5-监视reactive-所定义的一个响应式数据的某些属性"><a href="#5-监视reactive-所定义的一个响应式数据的某些属性" class="headerlink" title="5.监视reactive 所定义的一个响应式数据的某些属性"></a>5.监视reactive 所定义的一个响应式数据的某些属性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch([()=&gt;person.name,()=&gt;person.age],(newValue,oldValue)=&gt;&#123;</span><br><span class="line">  console.log(&#x27;name age变了&#x27;,newValue,oldValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><p>更改一下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setup()&#123;</span><br><span class="line">let sum=ref(0)</span><br><span class="line">let msg=ref(&#x27;你好&#x27;)</span><br><span class="line">let person=reactive(&#123;</span><br><span class="line">  name:&#x27;张三&#x27;,</span><br><span class="line">  age:18,</span><br><span class="line">  salary:20,</span><br><span class="line">  job:&#123;</span><br><span class="line">    j1:&#123;</span><br><span class="line">      j1s:9999</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里必须加上{deep:true}，否则监视不到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">  console.log(&#x27;job变了&#x27;,newValue,oldValue)</span><br><span class="line">&#125;,&#123;deep:true&#125;)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2024/11/07/About-Vue3/image-14.png" alt="alt text"><br>监视ref普通数据类型时，不用加.value,但如果是person（对象）就要加注意是ref类型时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">法一：加上.value就相当于监视的是reactive所监视的数据</span><br><span class="line">watch(person.value,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">  console.log(&#x27;person变了&#x27;,newValue,oldValue)</span><br><span class="line">&#125;,&#123;deep:false&#125;)</span><br><span class="line">法二：</span><br><span class="line">watch(person.value,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">  console.log(&#x27;person变了&#x27;,newValue,oldValue)</span><br><span class="line">&#125;,&#123;deep:true&#125;)</span><br></pre></td></tr></table></figure><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p><img src="/2024/11/07/About-Vue3/image-15.png" alt="alt text"></p><h2 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h2><p><img src="/2024/11/07/About-Vue3/image-16.png" alt="alt text"><br>就是把一些api封装，复用</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="/2024/11/07/About-Vue3/image-17.png" alt="alt text"><br>组合API就是把生命周期钩子写到setup中还要引入，如果写到setup外，就写箭头前面的名字<br>组合式API生命钩子的使用时期，比配置项的方法写优先级更高</p><p><img src="/2024/11/07/About-Vue3/image-18.png" alt="alt text"></p><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p><img src="/2024/11/07/About-Vue3/image-19.png" alt="alt text"></p><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><h4 id="原生dom事件"><a href="#原生dom事件" class="headerlink" title="原生dom事件"></a>原生dom事件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre @click=&quot;handler&quot;&gt;12345&lt;/pre&gt;</span><br><span class="line">&lt;pre @click=&quot;handler1(1,2,3,4,$event)&quot;&gt;12345&lt;/pre&gt;</span><br></pre></td></tr></table></figure><p>注意，必须是$event</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const handler = (event)=&gt;&#123;</span><br><span class="line">  console.log(event)</span><br><span class="line">&#125;   </span><br><span class="line">function handler1(p1,p2,p3,p4,p5)&#123;</span><br><span class="line">  console.log(p1,p2,p3,p4,p5)</span><br><span class="line">  //第五个参数是事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组件也可以绑定原生DOM事件"><a href="#组件也可以绑定原生DOM事件" class="headerlink" title="组件也可以绑定原生DOM事件"></a>组件也可以绑定原生DOM事件</h4><p>但如果子组件接收了的话，就是自定义事件<br>注意一个问题，父组件给子组件绑定一个自定义事件，实际上是给子组件的<font color="Red">根组件</font>绑定，在本例中就是给.son绑定,所以你点击子组件的任意一处都会触发事件，利用了事件委托</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;FirstChild @click=&quot;handler2&quot;/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function handler2()&#123;</span><br><span class="line">  console.log(123)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;son&quot;&gt;</span><br><span class="line">  &lt;h2&gt;姓名1是:&#123;&#123; name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;button @click=&quot;get&quot;&gt;点我获取姓名&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="自定义事件：子给父传递数组"><a href="#自定义事件：子给父传递数组" class="headerlink" title="自定义事件：子给父传递数组"></a>自定义事件：子给父传递数组</h4><p>父组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;SecChild @xxx=&quot;handler3&quot;/&gt;</span><br></pre></td></tr></table></figure><p>父组件中的回调</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function handler3(p1)&#123;</span><br><span class="line"> console.log(p1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;son2&quot;&gt;</span><br><span class="line">    &lt;h2&gt;22222&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;handler&quot;&gt;自定义&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>利用defineEmits方法返回<font color="Purple">函数</font>触发自定义事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">//不需要引入</span><br><span class="line">let emit=defineEmits([&#x27;xxx&#x27;])</span><br><span class="line">function handler()&#123;</span><br><span class="line">  emit(&#x27;xxx&#x27;,&#x27;xs&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>其中可以利用emit给父组件回传参数，</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在Vue3中，子组件给父组件传递数据需要通过自定义事件进行。在父组件中，形式和Vue2相同，就是在组件实例对象上绑定一个事件并且让他的值等于父组件的一个回调函数。<br>而在子组件中，我们需要通过emit&#x3D;defineEmits([‘xxx’])得到在父组件中绑定的事件，然后就可以直接传参。父组件的回调函数接受的参数就是子组件调用自定义事件所传的参数<br>@xxx&#x3D;”handler3”<br>这里的 xxx 并不是一个变量或响应式属性，而是一个事件名。当子组件通过 this.$emit(‘xxx’, …) 触发这个事件时，不管 xxx 这个字符串本身是否变化，只要事件名匹配，父组件中对应的监听器就会触发，并调用 handler3 方法。</p><h2 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h2><p>1.npm install mitt –save<br>2.在main.js中<br>import mitt from ‘mitt’<br>const $bus &#x3D; mitt()<br>export default $bus<br>组件一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import $bus from &#x27;../main&#x27;</span><br><span class="line">import &#123; onMounted &#125; from &#x27;vue&#x27;;</span><br><span class="line">onMounted(()=&gt;&#123;</span><br><span class="line">  $bus.on(&#x27;car&#x27;,(car)=&gt;&#123;</span><br><span class="line">    console.log(car)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>组件2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;son2&quot;&gt;</span><br><span class="line">    &lt;h2&gt;我是2&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;send&quot;&gt;给我姐姐&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import $bus from &#x27;../main&#x27;</span><br><span class="line"></span><br><span class="line">function send()&#123;</span><br><span class="line">  $bus.emit(&#x27;car&#x27;,&#123;car:&#x27;123&#x27;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h2><p>详情见：<a href="https://cn.vuejs.org/guide/built-ins/transition.html">https://cn.vuejs.org/guide/built-ins/transition.html</a><br><a href="./About-Vue3/20.png"></a><br><font color="red">注<font>：<code>&lt;Transition&gt;</code>仅支持单个元素或组件作为其插槽内容。如果内容是一个组件，这个组件必须仅有一个根元素。</font></font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.v-enter-active,</span><br><span class="line">.v-leave-active &#123;</span><br><span class="line">  transition: opacity 0.5s ease;</span><br><span class="line">&#125;</span><br><span class="line">.v-enter-from,</span><br><span class="line">.v-leave-to &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插槽slot"><a href="#插槽slot" class="headerlink" title="插槽slot"></a>插槽slot</h2><p><a href="https://cn.vuejs.org/guide/components/slots.html#slots">https://cn.vuejs.org/guide/components/slots.html#slots</a><br><code>&lt;slot&gt;</code>元素是一个插槽出口，标示了父元素提供的插槽内容将在哪里被渲染。就是如果想通过父组件在子组件中写内容，需要在子组件中加插槽</p><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p><strong>具名插槽需要在父组件中用template</strong><br><code>&lt;slot&gt;</code>元素可以有一个特殊的name，<code>&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-slot:header&gt;</span><br><span class="line">  &lt;!-- header 插槽的内容放这里 --&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>v-slot 有对应的简写 #，因此<code>&lt;template v-slot:header&gt;</code>可以简写为<code>&lt;template #header&gt;</code>,其意思就是“将这部分模板片段传入子组件的 header 插槽中”</p><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>插槽的内容可能想要同时使用父组件域内和子组件域内的数据。<br>子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;slot :text=&quot;greetingMessage&quot; :count=&quot;1&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>父组件<br>通过子组件标签上的 v-slot 指令，直接接收到了一个插槽 props 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent v-slot=&quot;slotProps&quot;&gt;</span><br><span class="line">  &#123;&#123; slotProps.text &#125;&#125; &#123;&#123; slotProps.count &#125;&#125;</span><br><span class="line">&lt;/MyComponent&gt;</span><br></pre></td></tr></table></figure><p>使用解构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent v-slot=&quot;&#123; text, count &#125;&quot;&gt;</span><br><span class="line">  &#123;&#123; text &#125;&#125; &#123;&#123; count &#125;&#125;</span><br><span class="line">&lt;/MyComponent&gt;</span><br></pre></td></tr></table></figure><h3 id="具名作用域插槽"><a href="#具名作用域插槽" class="headerlink" title="具名作用域插槽"></a>具名作用域插槽</h3><p>插槽 props 可以作为 v-slot 指令的值被访问到：v-slot:name&#x3D;”slotProps”。当使用缩写时是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent&gt;</span><br><span class="line">  &lt;template #header=&quot;headerProps&quot;&gt;</span><br><span class="line">    &#123;&#123; headerProps &#125;&#125;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/MyComponent&gt;</span><br></pre></td></tr></table></figure><p>向具名插槽中传入 props：注意插槽上的 name 是一个 Vue 特别保留的 attribute，<strong>不会</strong>作为 props 传递给插槽</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;slot name=&quot;header&quot; message=&quot;hello&quot;&gt;&lt;/slot&gt;</span><br></pre></td></tr></table></figure><p>如果你同时使用了具名插槽与默认插槽，则需要为默认插槽使用显式的<code>&lt;template&gt;</code>标签。尝试直接为组件添加 v-slot 指令将导致编译错误。这是为了避免因默认插槽的 props 的作用域而困惑。举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;slot :message=&quot;hello&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;slot name=&quot;footer&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">template</span><br><span class="line">&lt;!-- 该模板无法编译 --&gt;</span><br><span class="line">&lt;MyComponent v-slot=&quot;&#123; message &#125;&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;template #footer&gt;</span><br><span class="line">    &lt;!-- message 属于默认插槽，此处不可用 --&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/MyComponent&gt;</span><br></pre></td></tr></table></figure><p>为默认插槽使用显式的 <template> 标签有助于更清晰地指出 message 属性在其他插槽中不可用：</template></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent&gt;</span><br><span class="line">  &lt;!-- 使用显式的默认插槽 --&gt;</span><br><span class="line">  &lt;template #default=&quot;&#123; message &#125;&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">  &lt;template #footer&gt;</span><br><span class="line">    &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/MyComponent&gt;</span><br></pre></td></tr></table></figure><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="Vue-Router和组合式-API"><a href="#Vue-Router和组合式-API" class="headerlink" title="Vue Router和组合式 API"></a>Vue Router和组合式 API</h3><p>我们需要使用一些新的函数来代替访问 this 和组件内导航守卫。</p><h4 id="使用路由，路由器"><a href="#使用路由，路由器" class="headerlink" title="使用路由，路由器"></a>使用路由，路由器</h4><p>因为我们在 setup 里面没有访问 this，所以我们不能直接访问 this.$router 或 this.$route。作为替代，我们使用 useRouter 和 useRoute 函数：<br><code>import &#123; useRouter, useRoute &#125; from &#39;vue-router&#39;</code><br><code>const router = useRouter()</code><br><code>const route = useRoute()</code><br>route.matched:可以获取当前路由的各种信息</p><h4 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h4><p><code>import &#123; onBeforeRouteLeave, onBeforeRouteUpdate &#125; from &#39;vue-router&#39;</code></p><p>给组件起名，需要再写一个<script></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">  export default&#123;</span><br><span class="line">    name:&quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></script></p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客~</title>
      <link href="/2024/11/06/MyFirstBlog/"/>
      <url>/2024/11/06/MyFirstBlog/</url>
      
        <content type="html"><![CDATA[<p>在隔窗老师的帮助下，我的博客终于搭建完毕！感谢隔窗老师！！！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
